
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
        <link rel="canonical" href="https://docs.hermez.io/zkEVM/State-Machines/Storage/Storage-State-Machine-typ/">
      
      <link rel="icon" href="../../../../favicon.ico">
      <meta name="generator" content="mkdocs-1.3.1, mkdocs-material-8.3.9">
    
    
      
        <title>Storage - Polygon zkEVM Documentation</title>
      
    
    
      <link rel="stylesheet" href="../../../../assets/stylesheets/main.1d29e8d0.min.css">
      
        
        <link rel="stylesheet" href="../../../../assets/stylesheets/palette.cbb835fc.min.css">
        
          
          
          <meta name="theme-color" content="#7e56c2">
        
      
      
    
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
    <script>__md_scope=new URL("../../../..",location),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
  </head>
  
  
    
    
    
    
    
    <body dir="ltr" data-md-color-scheme="" data-md-color-primary="deep-purple" data-md-color-accent="">
  
    
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#the-storage-state-machine" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--lifted" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href="../../../.." title="Polygon zkEVM Documentation" class="md-header__button md-logo" aria-label="Polygon zkEVM Documentation" data-md-component="logo">
      
  <img src="../../../../logo-white.svg" alt="logo">

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2Z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            Polygon zkEVM Documentation
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Storage
            
          </span>
        </div>
      </div>
    </div>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12Z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" aria-label="Clear" tabindex="-1">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41Z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
      <div class="md-header__source">
        <a href="https://github.com/hermeznetwork/hermez-docs" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.1.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81z"/></svg>
  </div>
  <div class="md-source__repository">
    GitHub
  </div>
</a>
      </div>
    
  </nav>
  
    
      
<nav class="md-tabs" aria-label="Tabs" data-md-component="tabs">
  <div class="md-tabs__inner md-grid">
    <ul class="md-tabs__list">
      
        
  
  
    
  


  
  
  
    

  
  
  
    <li class="md-tabs__item">
      <a href="../../../Basic-Concepts/introduction/" class="md-tabs__link md-tabs__link--active">
        Polygon zkEVM
      </a>
    </li>
  

  

      
        
  
  


  
  
  
    

  
  
  
    <li class="md-tabs__item">
      <a href="../../../../Hermez_1.0/about/scalability/" class="md-tabs__link">
        Polygon Hermez 1.0
      </a>
    </li>
  

  

      
    </ul>
  </div>
</nav>
    
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

  


<nav class="md-nav md-nav--primary md-nav--lifted" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../../../.." title="Polygon zkEVM Documentation" class="md-nav__button md-logo" aria-label="Polygon zkEVM Documentation" data-md-component="logo">
      
  <img src="../../../../logo-white.svg" alt="logo">

    </a>
    Polygon zkEVM Documentation
  </label>
  
    <div class="md-nav__source">
      <a href="https://github.com/hermeznetwork/hermez-docs" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.1.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81z"/></svg>
  </div>
  <div class="md-source__repository">
    GitHub
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      

  
  
    
  
  
    
    <li class="md-nav__item md-nav__item--active md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_1" type="checkbox" id="__nav_1" checked>
      
      
      
      
        <label class="md-nav__link" for="__nav_1">
          Polygon zkEVM
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="Polygon zkEVM" data-md-level="1">
        <label class="md-nav__title" for="__nav_1">
          <span class="md-nav__icon md-icon"></span>
          Polygon zkEVM
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_1_1" type="checkbox" id="__nav_1_1" >
      
      
      
      
        <label class="md-nav__link" for="__nav_1_1">
          Basic Concepts
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="Basic Concepts" data-md-level="2">
        <label class="md-nav__title" for="__nav_1_1">
          <span class="md-nav__icon md-icon"></span>
          Basic Concepts
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../../Basic-Concepts/introduction/" class="md-nav__link">
        Introduction
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../../Basic-Concepts/fibonacci/" class="md-nav__link">
        First Example: Fibonacci
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../../Basic-Concepts/simple-state-machine/" class="md-nav__link">
        Simple State Machine
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../../Basic-Concepts/modular-design/" class="md-nav__link">
        Modular Design
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
            
              
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_1_2" type="checkbox" id="__nav_1_2" >
      
      
      
      
        <label class="md-nav__link" for="__nav_1_2">
          Architecture
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="Architecture" data-md-level="2">
        <label class="md-nav__title" for="__nav_1_2">
          <span class="md-nav__icon md-icon"></span>
          Architecture
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../../Architecture/zkProver/" class="md-nav__link">
        zkProver
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
            
              
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_1_3" type="checkbox" id="__nav_1_3" >
      
      
      
      
        <label class="md-nav__link" for="__nav_1_3">
          zkASM
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="zkASM" data-md-level="2">
        <label class="md-nav__title" for="__nav_1_3">
          <span class="md-nav__icon md-icon"></span>
          zkASM
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../../zkASM/introduction/" class="md-nav__link">
        Introduction
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../../zkASM/basic-syntax/" class="md-nav__link">
        Basic Syntax
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../../zkASM/some-examples/" class="md-nav__link">
        Some Examples
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../../zkASM/related-repos/" class="md-nav__link">
        Related Repositories
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
            
              
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_1_4" type="checkbox" id="__nav_1_4" >
      
      
      
      
        <label class="md-nav__link" for="__nav_1_4">
          PIL
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="PIL" data-md-level="2">
        <label class="md-nav__title" for="__nav_1_4">
          <span class="md-nav__icon md-icon"></span>
          PIL
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../../PIL/introduction/" class="md-nav__link">
        Introduction
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../../PIL/hello-world-examples/" class="md-nav__link">
        Hello Word Examples
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../../PIL/components/" class="md-nav__link">
        Components
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../../PIL/cyclical-nature/" class="md-nav__link">
        Cyclical Nature
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../../PIL/modularity/" class="md-nav__link">
        Modularity
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../../PIL/advanced-features/" class="md-nav__link">
        Advanced Features
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../../PIL/related-repos/" class="md-nav__link">
        Related Repositories
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
            
              
  
  
    
  
  
    
    <li class="md-nav__item md-nav__item--active md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_1_5" type="checkbox" id="__nav_1_5" checked>
      
      
      
      
        <label class="md-nav__link" for="__nav_1_5">
          State Machines
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="State Machines" data-md-level="2">
        <label class="md-nav__title" for="__nav_1_5">
          <span class="md-nav__icon md-icon"></span>
          State Machines
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../Arithmetic/Arithmetic-State-Machine-typ/" class="md-nav__link">
        Arithmetic
      </a>
    </li>
  

            
          
            
              
  
  
    
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" data-md-toggle="toc" type="checkbox" id="__toc">
      
      
        
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          Storage
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="./" class="md-nav__link md-nav__link--active">
        Storage
      </a>
      
        

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#about-this-document" class="md-nav__link">
    About this Document
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#introduction" class="md-nav__link">
    Introduction
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#storage-design-preliminaries" class="md-nav__link">
    Storage Design - Preliminaries
  </a>
  
    <nav class="md-nav" aria-label="Storage Design - Preliminaries">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#merkle-trees" class="md-nav__link">
    Merkle Trees
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#using-keys-to-navigate-a-merkle-tree" class="md-nav__link">
    Using Keys To Navigate A Merkle Tree
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#a-merkle-proof-example" class="md-nav__link">
    A Merkle Proof Example
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#building-simplified-binary-sparse-merkle-trees" class="md-nav__link">
    Building Simplified Binary Sparse Merkle Trees
  </a>
  
    <nav class="md-nav" aria-label="Building Simplified Binary Sparse Merkle Trees">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#a-binary-smt-with-one-key-value-pair" class="md-nav__link">
    A Binary SMT With One Key-Value Pair
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#binary-smts-with-two-key-value-pairs" class="md-nav__link">
    Binary SMTs With Two Key-Value Pairs
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#a-few-more-concepts-about-binary-smts" class="md-nav__link">
    A Few More Concepts About Binary SMTs
  </a>
  
    <nav class="md-nav" aria-label="A Few More Concepts About Binary SMTs">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#example-1-leaf-levels" class="md-nav__link">
    Example 1. Leaf Levels
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#the-remaining-key" class="md-nav__link">
    The Remaining Key
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example-2-remaining-keys" class="md-nav__link">
    Example 2. Remaining Keys
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#the-fake-leaf-attack" class="md-nav__link">
    The Fake-Leaf Attack
  </a>
  
    <nav class="md-nav" aria-label="The Fake-Leaf Attack">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#scenario-a-fake-smt-leaf" class="md-nav__link">
    Scenario A: Fake SMT Leaf
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#solution-to-the-fake-leaf-attack" class="md-nav__link">
    Solution To The Fake-Leaf Attack
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#non-binding-key-value-pairs" class="md-nav__link">
    Non-Binding Key-Value Pairs
  </a>
  
    <nav class="md-nav" aria-label="Non-Binding Key-Value Pairs">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#example-3-indistinguishable-leaves" class="md-nav__link">
    Example 3. (Indistinguishable Leaves)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#solution-to-the-non-binding-key-value-problem" class="md-nav__link">
    Solution To The Non-Binding Key-Value Problem
  </a>
  
    <nav class="md-nav" aria-label="Solution To The Non-Binding Key-Value Problem">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#the-naive-solution" class="md-nav__link">
    The Naïve Solution
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#a-better-solution" class="md-nav__link">
    A Better Solution
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#introducing-zero-knowledge" class="md-nav__link">
    Introducing Zero-Knowledge
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example-4-zero-knowledge-merkle-proof" class="md-nav__link">
    Example 4. (Zero-Knowledge Merkle Proof)
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#basic-operations-storage-actions" class="md-nav__link">
    Basic Operations (Storage Actions)
  </a>
  
    <nav class="md-nav" aria-label="Basic Operations (Storage Actions)">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#the-read-operation" class="md-nav__link">
    The READ Operation
  </a>
  
    <nav class="md-nav" aria-label="The READ Operation">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#example-5-when-the-key-is-not-set" class="md-nav__link">
    Example 5. When The Key Is Not Set
  </a>
  
    <nav class="md-nav" aria-label="Example 5. When The Key Is Not Set">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#case-1-when-the-key-leads-to-a-zero-node" class="md-nav__link">
    Case 1: When the key leads to a zero-node
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#case-2-when-the-key-leads-to-an-existing-leaf" class="md-nav__link">
    Case 2: When the key leads to an existing leaf
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#the-update-operation" class="md-nav__link">
    The UPDATE Operation
  </a>
  
    <nav class="md-nav" aria-label="The UPDATE Operation">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#example-6-update-step-2" class="md-nav__link">
    Example 6. UPDATE - Step 2
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#the-create-operation" class="md-nav__link">
    The CREATE Operation
  </a>
  
    <nav class="md-nav" aria-label="The CREATE Operation">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#case-1-new-key-navigates-to-a-zero-node" class="md-nav__link">
    Case 1: New Key Navigates To A Zero Node
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example-7-create-operation-at-a-zero-node" class="md-nav__link">
    Example 7. CREATE Operation at a Zero Node
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#case-2-new-key-navigates-to-a-non-zero-leaf" class="md-nav__link">
    Case 2: New Key Navigates To A Non-Zero Leaf
  </a>
  
    <nav class="md-nav" aria-label="Case 2: New Key Navigates To A Non-Zero Leaf">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#example-8-create-operation-with-a-single-branch-extension" class="md-nav__link">
    Example 8. CREATE Operation with a Single Branch Extension
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example-9-create-operation-with-multiple-branch-extensions" class="md-nav__link">
    Example 9. CREATE Operation with Multiple Branch Extensions
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#the-deleteremove-operation" class="md-nav__link">
    The DELETE/REMOVE Operation
  </a>
  
    <nav class="md-nav" aria-label="The DELETE/REMOVE Operation">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#case-1-delete-operation-leaves-with-non-zero-siblings" class="md-nav__link">
    Case 1: DELETE Operation - Leaves With Non-Zero Siblings
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#case-2-delete-operation-leaves-with-zero-siblings" class="md-nav__link">
    Case 2: DELETE Operation - Leaves With Zero Siblings
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#concluding-basic-operations" class="md-nav__link">
    Concluding Basic Operations
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#zkprover-storage-parameters" class="md-nav__link">
    zkProver Storage Parameters
  </a>
  
    <nav class="md-nav" aria-label="zkProver Storage Parameters">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#creating-keys-and-paths" class="md-nav__link">
    Creating Keys And Paths
  </a>
  
    <nav class="md-nav" aria-label="Creating Keys And Paths">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#how-keys-are-created" class="md-nav__link">
    How Keys Are Created
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#constructing-navigation-paths" class="md-nav__link">
    Constructing Navigation Paths
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#reconstructing-the-key-from-path-bits" class="md-nav__link">
    Reconstructing The Key From Path-Bits
  </a>
  
    <nav class="md-nav" aria-label="Reconstructing The Key From Path-Bits">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#example-key-reconstruction" class="md-nav__link">
    Example. Key Reconstruction
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#leaf-levels-and-integers-modulo-4" class="md-nav__link">
    Leaf Levels and Integers Modulo 4
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#alternate-cyclic-group-of-order-4" class="md-nav__link">
    Alternate Cyclic Group Of Order 4
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#a-special-cyclic-register-for-leaf-levels" class="md-nav__link">
    A Special Cyclic Register For Leaf Levels
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#the-textposeidon-hash" class="md-nav__link">
    The \(\text{POSEIDON}\) HASH
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#the-storage-state-machines-design-and-mechanism" class="md-nav__link">
    The Storage State Machine's Design and Mechanism
  </a>
  
    <nav class="md-nav" aria-label="The Storage State Machine's Design and Mechanism">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#the-storage-assembly" class="md-nav__link">
    The Storage Assembly
  </a>
  
    <nav class="md-nav" aria-label="The Storage Assembly">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#smt-action-selectors-in-the-primary-assembly-code" class="md-nav__link">
    SMT Action Selectors In The Primary Assembly Code
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#the-update-zkasm-code" class="md-nav__link">
    The UPDATE zkASM Code
  </a>
  
    <nav class="md-nav" aria-label="The UPDATE zkASM Code">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#key-reconstruction-in-zkasm" class="md-nav__link">
    Key Reconstruction In zkASM
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#checking-inclusion-of-old-value-in-old-root" class="md-nav__link">
    Checking Inclusion Of Old Value In Old Root
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#the-update-part-of-set_update" class="md-nav__link">
    The Update Part Of Set_UPDATE
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#the-rest-of-the-secondary-assembly-codes" class="md-nav__link">
    The Rest Of The Secondary Assembly Codes
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#the-storage-executor" class="md-nav__link">
    The Storage Executor
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#the-storage-pil" class="md-nav__link">
    The Storage PIL
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../Hashing/Hashing-State-Machine-typ/" class="md-nav__link">
        Hashing
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../Binary/Binary-State-Machine-typ/" class="md-nav__link">
        Binary
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../Memory/memory-state-machine/" class="md-nav__link">
        Memory
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../Memory-Align/memory-align-state-machine/" class="md-nav__link">
        Memory Align
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../Complementary/complementary-state-machines/" class="md-nav__link">
        Complementaries
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../Complementary/configuration-file/" class="md-nav__link">
        Configuration File
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_2" type="checkbox" id="__nav_2" >
      
      
      
      
        <label class="md-nav__link" for="__nav_2">
          Polygon Hermez 1.0
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="Polygon Hermez 1.0" data-md-level="1">
        <label class="md-nav__title" for="__nav_2">
          <span class="md-nav__icon md-icon"></span>
          Polygon Hermez 1.0
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_2_1" type="checkbox" id="__nav_2_1" >
      
      
      
      
        <label class="md-nav__link" for="__nav_2_1">
          About
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="About" data-md-level="2">
        <label class="md-nav__title" for="__nav_2_1">
          <span class="md-nav__icon md-icon"></span>
          About
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../../../Hermez_1.0/about/scalability/" class="md-nav__link">
        Ethereum Scalability and zk-Rollups
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../../../Hermez_1.0/about/value-proposition/" class="md-nav__link">
        Polygon Hermez Value Proposition
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../../../Hermez_1.0/about/model/" class="md-nav__link">
        Polygon Hermez Network Model
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../../../Hermez_1.0/about/security/" class="md-nav__link">
        Security
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
            
              
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_2_2" type="checkbox" id="__nav_2_2" >
      
      
      
      
        <label class="md-nav__link" for="__nav_2_2">
          Users
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="Users" data-md-level="2">
        <label class="md-nav__title" for="__nav_2_2">
          <span class="md-nav__icon md-icon"></span>
          Users
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../../../Hermez_1.0/users/hermez-wallet/" class="md-nav__link">
        Polygon Hermez Wallet
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../../../Hermez_1.0/users/mainnet/" class="md-nav__link">
        Polygon Hermez Mainnet
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../../../Hermez_1.0/users/testnet/" class="md-nav__link">
        Polygon Hermez Testnet
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../../../Hermez_1.0/users/exchanges/" class="md-nav__link">
        Exchanges
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
            
              
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_2_3" type="checkbox" id="__nav_2_3" >
      
      
      
      
        <label class="md-nav__link" for="__nav_2_3">
          Developers
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="Developers" data-md-level="2">
        <label class="md-nav__title" for="__nav_2_3">
          <span class="md-nav__icon md-icon"></span>
          Developers
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../../../Hermez_1.0/developers/dev-guide/" class="md-nav__link">
        Developer Guide
      </a>
    </li>
  

            
          
            
              
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_2_3_2" type="checkbox" id="__nav_2_3_2" >
      
      
      
      
        <label class="md-nav__link" for="__nav_2_3_2">
          Protocol
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="Protocol" data-md-level="3">
        <label class="md-nav__title" for="__nav_2_3_2">
          <span class="md-nav__icon md-icon"></span>
          Protocol
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_2_3_2_1" type="checkbox" id="__nav_2_3_2_1" >
      
      
      
      
        <label class="md-nav__link" for="__nav_2_3_2_1">
          Polygon Hermez zkRollup protocol
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="Polygon Hermez zkRollup protocol" data-md-level="4">
        <label class="md-nav__title" for="__nav_2_3_2_1">
          <span class="md-nav__icon md-icon"></span>
          Polygon Hermez zkRollup protocol
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../../../Hermez_1.0/developers/protocol/hermez-protocol/protocol/" class="md-nav__link">
        Core protocol
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../../../Hermez_1.0/developers/protocol/hermez-protocol/contracts/contracts/" class="md-nav__link">
        Smart contracts
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../../../Hermez_1.0/developers/protocol/hermez-protocol/circuits/circuits/" class="md-nav__link">
        Circuits
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../../../Hermez_1.0/developers/protocol/consensus/consensus/" class="md-nav__link">
        Forging consensus protocol
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../../../Hermez_1.0/developers/protocol/withdrawal-delayer/withdrawal-delayer/" class="md-nav__link">
        Withdrawal delayer protocol
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../../../Hermez_1.0/developers/sdk/" class="md-nav__link">
        Examples/SDK
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../../../Hermez_1.0/developers/api/" class="md-nav__link">
        API
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../../../Hermez_1.0/developers/batch-explorer/" class="md-nav__link">
        Batch Explorer
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../../../Hermez_1.0/developers/price-updater/" class="md-nav__link">
        Polygon Hermez NodePrice Updater
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../../../Hermez_1.0/developers/glossary/" class="md-nav__link">
        Glossary
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
            
              
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_2_4" type="checkbox" id="__nav_2_4" >
      
      
      
      
        <label class="md-nav__link" for="__nav_2_4">
          FAQ
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="FAQ" data-md-level="2">
        <label class="md-nav__title" for="__nav_2_4">
          <span class="md-nav__icon md-icon"></span>
          FAQ
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../../../Hermez_1.0/faq/end-users/" class="md-nav__link">
        End-Users
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../../../Hermez_1.0/faq/integrators/" class="md-nav__link">
        Integrators
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../../../Hermez_1.0/faq/coordinators/" class="md-nav__link">
        Coordinators
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../../../Hermez_1.0/faq/pod/" class="md-nav__link">
        Proof of Donation
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../../../Hermez_1.0/faq/other/" class="md-nav__link">
        Other
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#about-this-document" class="md-nav__link">
    About this Document
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#introduction" class="md-nav__link">
    Introduction
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#storage-design-preliminaries" class="md-nav__link">
    Storage Design - Preliminaries
  </a>
  
    <nav class="md-nav" aria-label="Storage Design - Preliminaries">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#merkle-trees" class="md-nav__link">
    Merkle Trees
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#using-keys-to-navigate-a-merkle-tree" class="md-nav__link">
    Using Keys To Navigate A Merkle Tree
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#a-merkle-proof-example" class="md-nav__link">
    A Merkle Proof Example
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#building-simplified-binary-sparse-merkle-trees" class="md-nav__link">
    Building Simplified Binary Sparse Merkle Trees
  </a>
  
    <nav class="md-nav" aria-label="Building Simplified Binary Sparse Merkle Trees">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#a-binary-smt-with-one-key-value-pair" class="md-nav__link">
    A Binary SMT With One Key-Value Pair
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#binary-smts-with-two-key-value-pairs" class="md-nav__link">
    Binary SMTs With Two Key-Value Pairs
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#a-few-more-concepts-about-binary-smts" class="md-nav__link">
    A Few More Concepts About Binary SMTs
  </a>
  
    <nav class="md-nav" aria-label="A Few More Concepts About Binary SMTs">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#example-1-leaf-levels" class="md-nav__link">
    Example 1. Leaf Levels
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#the-remaining-key" class="md-nav__link">
    The Remaining Key
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example-2-remaining-keys" class="md-nav__link">
    Example 2. Remaining Keys
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#the-fake-leaf-attack" class="md-nav__link">
    The Fake-Leaf Attack
  </a>
  
    <nav class="md-nav" aria-label="The Fake-Leaf Attack">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#scenario-a-fake-smt-leaf" class="md-nav__link">
    Scenario A: Fake SMT Leaf
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#solution-to-the-fake-leaf-attack" class="md-nav__link">
    Solution To The Fake-Leaf Attack
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#non-binding-key-value-pairs" class="md-nav__link">
    Non-Binding Key-Value Pairs
  </a>
  
    <nav class="md-nav" aria-label="Non-Binding Key-Value Pairs">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#example-3-indistinguishable-leaves" class="md-nav__link">
    Example 3. (Indistinguishable Leaves)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#solution-to-the-non-binding-key-value-problem" class="md-nav__link">
    Solution To The Non-Binding Key-Value Problem
  </a>
  
    <nav class="md-nav" aria-label="Solution To The Non-Binding Key-Value Problem">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#the-naive-solution" class="md-nav__link">
    The Naïve Solution
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#a-better-solution" class="md-nav__link">
    A Better Solution
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#introducing-zero-knowledge" class="md-nav__link">
    Introducing Zero-Knowledge
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example-4-zero-knowledge-merkle-proof" class="md-nav__link">
    Example 4. (Zero-Knowledge Merkle Proof)
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#basic-operations-storage-actions" class="md-nav__link">
    Basic Operations (Storage Actions)
  </a>
  
    <nav class="md-nav" aria-label="Basic Operations (Storage Actions)">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#the-read-operation" class="md-nav__link">
    The READ Operation
  </a>
  
    <nav class="md-nav" aria-label="The READ Operation">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#example-5-when-the-key-is-not-set" class="md-nav__link">
    Example 5. When The Key Is Not Set
  </a>
  
    <nav class="md-nav" aria-label="Example 5. When The Key Is Not Set">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#case-1-when-the-key-leads-to-a-zero-node" class="md-nav__link">
    Case 1: When the key leads to a zero-node
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#case-2-when-the-key-leads-to-an-existing-leaf" class="md-nav__link">
    Case 2: When the key leads to an existing leaf
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#the-update-operation" class="md-nav__link">
    The UPDATE Operation
  </a>
  
    <nav class="md-nav" aria-label="The UPDATE Operation">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#example-6-update-step-2" class="md-nav__link">
    Example 6. UPDATE - Step 2
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#the-create-operation" class="md-nav__link">
    The CREATE Operation
  </a>
  
    <nav class="md-nav" aria-label="The CREATE Operation">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#case-1-new-key-navigates-to-a-zero-node" class="md-nav__link">
    Case 1: New Key Navigates To A Zero Node
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example-7-create-operation-at-a-zero-node" class="md-nav__link">
    Example 7. CREATE Operation at a Zero Node
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#case-2-new-key-navigates-to-a-non-zero-leaf" class="md-nav__link">
    Case 2: New Key Navigates To A Non-Zero Leaf
  </a>
  
    <nav class="md-nav" aria-label="Case 2: New Key Navigates To A Non-Zero Leaf">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#example-8-create-operation-with-a-single-branch-extension" class="md-nav__link">
    Example 8. CREATE Operation with a Single Branch Extension
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example-9-create-operation-with-multiple-branch-extensions" class="md-nav__link">
    Example 9. CREATE Operation with Multiple Branch Extensions
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#the-deleteremove-operation" class="md-nav__link">
    The DELETE/REMOVE Operation
  </a>
  
    <nav class="md-nav" aria-label="The DELETE/REMOVE Operation">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#case-1-delete-operation-leaves-with-non-zero-siblings" class="md-nav__link">
    Case 1: DELETE Operation - Leaves With Non-Zero Siblings
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#case-2-delete-operation-leaves-with-zero-siblings" class="md-nav__link">
    Case 2: DELETE Operation - Leaves With Zero Siblings
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#concluding-basic-operations" class="md-nav__link">
    Concluding Basic Operations
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#zkprover-storage-parameters" class="md-nav__link">
    zkProver Storage Parameters
  </a>
  
    <nav class="md-nav" aria-label="zkProver Storage Parameters">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#creating-keys-and-paths" class="md-nav__link">
    Creating Keys And Paths
  </a>
  
    <nav class="md-nav" aria-label="Creating Keys And Paths">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#how-keys-are-created" class="md-nav__link">
    How Keys Are Created
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#constructing-navigation-paths" class="md-nav__link">
    Constructing Navigation Paths
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#reconstructing-the-key-from-path-bits" class="md-nav__link">
    Reconstructing The Key From Path-Bits
  </a>
  
    <nav class="md-nav" aria-label="Reconstructing The Key From Path-Bits">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#example-key-reconstruction" class="md-nav__link">
    Example. Key Reconstruction
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#leaf-levels-and-integers-modulo-4" class="md-nav__link">
    Leaf Levels and Integers Modulo 4
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#alternate-cyclic-group-of-order-4" class="md-nav__link">
    Alternate Cyclic Group Of Order 4
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#a-special-cyclic-register-for-leaf-levels" class="md-nav__link">
    A Special Cyclic Register For Leaf Levels
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#the-textposeidon-hash" class="md-nav__link">
    The \(\text{POSEIDON}\) HASH
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#the-storage-state-machines-design-and-mechanism" class="md-nav__link">
    The Storage State Machine's Design and Mechanism
  </a>
  
    <nav class="md-nav" aria-label="The Storage State Machine's Design and Mechanism">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#the-storage-assembly" class="md-nav__link">
    The Storage Assembly
  </a>
  
    <nav class="md-nav" aria-label="The Storage Assembly">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#smt-action-selectors-in-the-primary-assembly-code" class="md-nav__link">
    SMT Action Selectors In The Primary Assembly Code
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#the-update-zkasm-code" class="md-nav__link">
    The UPDATE zkASM Code
  </a>
  
    <nav class="md-nav" aria-label="The UPDATE zkASM Code">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#key-reconstruction-in-zkasm" class="md-nav__link">
    Key Reconstruction In zkASM
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#checking-inclusion-of-old-value-in-old-root" class="md-nav__link">
    Checking Inclusion Of Old Value In Old Root
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#the-update-part-of-set_update" class="md-nav__link">
    The Update Part Of Set_UPDATE
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#the-rest-of-the-secondary-assembly-codes" class="md-nav__link">
    The Rest Of The Secondary Assembly Codes
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#the-storage-executor" class="md-nav__link">
    The Storage Executor
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#the-storage-pil" class="md-nav__link">
    The Storage PIL
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          <div class="md-content" data-md-component="content">
            <article class="md-content__inner md-typeset">
              
                
  <a href="https://github.com/hermeznetwork/hermez-docs/edit/master/docs/zkEVM/State-Machines/Storage/Storage-State-Machine-typ.md" title="Edit this page" class="md-content__button md-icon">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20.71 7.04c.39-.39.39-1.04 0-1.41l-2.34-2.34c-.37-.39-1.02-.39-1.41 0l-1.84 1.83 3.75 3.75M3 17.25V21h3.75L17.81 9.93l-3.75-3.75L3 17.25Z"/></svg>
  </a>



<p>[ToC]</p>
<h1 id="the-storage-state-machine">The Storage State Machine</h1>
<p>The Storage State Machine (SM) is responsible for all operations on data stored in the zkProver's storage. It receives instructions from the Main State Machine, called <strong><em>Storage Actions</em></strong>. These Storage Actions are typical database operations; Create, Read, Update and Delete (CRUD).</p>
<p>The Storage SM is in fact a micro-processor with the firm-ware and the hardware parts.</p>
<p>It is in the firmware part of the Storage SM where the logic and rules are set up, expressed in JSON format and stored in a ROM. A novel language, called the <strong>zero-knowledge Assembly</strong> (zkASM), has been developed by the team. It is a language especially designed to map instructions from the zkProver's Main SM to other state machines, in this case, to the Storage SM's Executor. The Main SM's instructions, or Storage Actions, are parsed to the Storage SM Executor for execution in compliance with the rules and logic specified in the JSON-file.</p>
<p>The hardware part uses another novel language, called <strong>Polynomial Identity Language</strong> (PIL), which is especially designed for the zkProver, because almost all state machines express computations in terms of polynomials. State transitions in state machines must satisfy computation-specific polynomial identities.</p>
<p>The Storage SM's Executor carries out all Storage Actions (executes these operations), and also generates committed and constant polynomials.</p>
<p>PIL codes, in the zkProver, are used to check correct execution of SM-specific Actions. They therefore take as inputs all committed and constant polynomials.</p>
<p>In order to achieve zero-knowledge, all data is stored in the form of Merkle Trees, which means the Storage SM often makes requests of another state machine, the <a href="">Poseidon SM</a>, to perform hashing (referred to as <span class="arithmatex">\(\text{POSEIDON}\)</span> Actions).</p>
<h2 id="about-this-document">About this Document</h2>
<p>This document describes the Storage State Machine and the zkProver's Storage, which the Storage SM interacts with, by either reading or altering data stored in it. </p>
<p>This document therefore entails; </p>
<ul>
<li>The basic design of the zkProver's Storage and some preliminaries. i.e., How the Sparse Merkle Trees (SMTs) are built.</li>
<li>Explanations of each of the <a href="#basic-operations-storage-actions">Basic Operations</a> the Storage SM routinely performs.</li>
<li>Specific parameters the Storage SM uses, such as, how keys and paths are created, and the two <span class="arithmatex">\(\text{POSEIDON}\)</span> Hashes used in the SMTs.</li>
<li>As well as, the three main source-codes the Storage SM needs to function effectively. That is, <ul>
<li>the Storage Assembly code, </li>
<li>the Storage Executor (both in C and JavaScript), and </li>
<li>the PIL code, for all the polynomial constraints and proving correctness of execution.</li>
</ul>
</li>
</ul>
<h2 id="introduction">Introduction</h2>
<p>A generic state machine is characterised by; sets of states (as inputs) stored in registers, instructions to how the states should transition, and the resultant states (as outputs) stored as new values in the same registers. See Figure 1 below, for a standard state machine.</p>
<p>A state machine can be monolithic, where it is a prototype of one particular computation, while others may specialise with certain types of computations. Depending on the computational algorithm, a state machine may have to run through a number of state transitions before producing the desired output. Iterations of the same sequence of operations may be required, to the extend that most common state machines are cyclic by nature.</p>
<p><img alt="Figure 1: A Generic State Machine" src="../fig0-gen-state-mchn.png" /></p>
<div align="center"><b> Figure 1: A Generic State Machine </b></div>

<p>The Storage SM performs computations on the key-value data stored in special Merkle Trees, called <strong>Sparse Merkle Trees</strong> (SMTs). The basic operations it executes are; CREATE, READ, UPDATE and DELETE.</p>
<p>In the Storage SM, keys and values are strings of 256 bits and, for convenience, can be interpreted as 256-bit unsigned integers </p>
<p>The mechanics of the Storage SM and its basic operations are described in detail later in this document. For now, an example of the UPDATE Operation is given in order to illustrate the various components involved.</p>
<!-- 
### Example. An UPDATE Operation



Suppose the Main SM instructs the Storage SM to UPDATE a value $V_{\mathbf{old}}$, associated with a given key $K_{\mathbf{0123}}$ and stored in a binary SMT, to a new value $V_{\mathbf{01..7}}$. 

The Main SM must then provide, with its request, all data the Storage SM needs in order to correctly update the value $V_{\mathbf{old}}$. That is; the root of the SMT, the key-bits for navigation to the leaf, the Remaining Key, the leaf level, the old value and the new value, and all relevant siblings.

Typically, the Main SM will have navigated the tree to the leaf storing the value $V_{\mathbf{old}}$ and done the computations, but now requires the Storage SM to repeat the same computations in a verifiable manner. The Storage SM Executor will then do the following three things, simultaneously; 

1. Reconstructs the corresponding key, $K_{\mathbf{0123}}$, from both the remaining key found at the leaf and key-bits used to navigate to the leaf.
2. Ascertains that indeed the old value, $V_{\mathbf{old}}$, was included in the old root,
3. Carries out the UPDATE of the value $V_{\mathbf{old}}$ and all nodes along the path from the leaf to the root. 

For the sake of brevity, this illustration focuses on step 3, just the UPDATE part. That is, supposing that the leaf that stores the value $V_{\mathbf{01..7}}$ is found, and $V_{\mathbf{01..7}}$ was indeed included in computing the old root.

The task therefore, is to update the value and all the node values along the path from the leaf to the root, including the root. In other words, compute the new root from the new value and its given siblings.



Here's how the Storage SM does this,

*Step 1.* Computes the hash of the new value, 
$V_{\mathbf{01..7}} = \big( V_{\mathbf{0}}, V_{\mathbf{1}}, V_{\mathbf{2}}, V_{\mathbf{3}}, V_{\mathbf{4}}, V_{\mathbf{5}}, V_{\mathbf{6}}, V_{\mathbf{7}} \big)$
 call it the *Committed Value*; resulting in the hashed value,

\begin{aligned}
   \text{HV}_{\mathbf{0123}} = \big( \text{HV}_{\mathbf{0}}, \text{HV}_{\mathbf{1}}, \text{HV}_{\mathbf{2}}, \text{HV}_{\mathbf{3}} \big) = \text{Hash}\big( 0000\|V_{\mathbf{01..7}} \big).
\end{aligned} 

*Step 2.* Form the leaf by computing the hash of the concatenation of the remaining key $\text{RK}_{\mathbf{0123}} = \big( \text{RK}_{\mathbf{0}}, \text{RK}_{\mathbf{1}}, \text{RK}_{\mathbf{2}}, \text{RK}_{\mathbf{3}} \big)$ and the hashed value $\text{HV}_{\mathbf{0123}}$; yielding the leaf,

\begin{aligned}
   \text{LV}_{\mathbf{0123}} = \big( \text{LV}_{\mathbf{0}}, \text{LV}_{\mathbf{1}}, \text{LV}_{\mathbf{2}}, \text{LV}_{\mathbf{3}} \big) = \text{Hash}\big( 1000\| \text{RK}_{\mathbf{0123}} \| \text{HV}_{\mathbf{0123}} \big).
\end{aligned}

*Step 3.* Next, use the given sibling, say 
$\text{SB}_{\mathbf{0123}}  = \big( \text{SB}_{\mathbf{0}}, \text{SB}_{\mathbf{1}}, \text{SB}_{\mathbf{2}}, \text{SB}_{\mathbf{3}} \big)$
 to compute the branch value,

\begin{aligned}
   \text{BR}_{\mathbf{0123}} = \big( \text{BR}_{\mathbf{0}}, \text{BR}_{\mathbf{1}}, \text{BR}_{\mathbf{2}}, \text{BR}_{\mathbf{3}} \big) = \text{Hash}\big( 0000\| \text{SB}_{\mathbf{0123}} \| \text{LV}_{\mathbf{0123}} \big).
\end{aligned}

*Step 4.* Again, use the next given sibling, say
$\text{SB}_{\mathbf{4567}}  = \big( \text{SB}_{\mathbf{4}}, \text{SB}_{\mathbf{5}}, \text{SB}_{\mathbf{6}}, \text{SB}_{\mathbf{7}} \big)$
    to compute the next branch. If this sibling is the last one, then the resultant is the new root,

\begin{aligned}
   \text{ROOT}_{\mathbf{0123}} = \big( \text{RT}_{\mathbf{0}}, \text{RT}_{\mathbf{1}}, \text{RT}_{\mathbf{2}}, \text{RT}_{\mathbf{3}} \big) = \text{Hash}\big( 0000\| \text{SB}_{\mathbf{4567}} \| \text{BR}_{\mathbf{0123}} \big).
\end{aligned}

See Figure 2 below, for an illustration of this UPDATE operation, using the $\text{POSEIDON}$ Hash. 




![Figure 2: Value UPDATE Example](fig0-updt-mkl-tree.png)
<div align="center"><b> Figure 2: Value UPDATE Example </b></div>


The above example captures in summary the following aspects about the Storage SM; 

- A brief preview of how the SMTs are constructed,
- A display of how a Merkle proof (climbing the tree) looks like in the Storage SM context, 
- The role played by the $\text{POSEIDON}$ Hash function, when carrying out the basic operations (CRUD).
- Also, the two $\text{POSEIDON}$ Hash functions, which are set apart by whether the capacity is $0000$ or $1000$. 

Nonetheless, given that we are dealing with a state machine here, there is a lot more detail needed on what is actually involved in the background. What is commonly a trivial computation when using a high-level programming language, requires a bit more machinery to be put in place in low-level programming.

A much more slower pace is henceforth adopted. Experienced developers can use the Table of Contents to jump to sections of interest.
 -->

<h2 id="storage-design-preliminaries">Storage Design - Preliminaries</h2>
<p>Storage in the zkProver is designed in such a way that aggregators and verifiers can easily and efficiently interact with stored data. This is data needed for providing zero-knowledge proofs, or verifying state.</p>
<p>Data is stored in the form of a special Sparse Merkle Tree (SMT), which is a tree that combines the concept of a Merkle Tree and that of a Patricia tree.</p>
<p>What follows is an explanation of how the zkProver storage, as a database, is designed. This design is based on how the Sparse Merkle Trees are constructed and how they store <em>keys</em> and <em>values</em>.</p>
<h3 id="merkle-trees">Merkle Trees</h3>
<p>A typical Merkle tree has <strong><em>leaves</em></strong>, <strong><em>branches</em></strong> and a <strong><em>root</em></strong>. A leaf is a node with no child-nodes, while a branch is a node with child-nodes. A root is therefore a node with no parent-node.</p>
<p>See Figure 3 below, for an example of how a hash function 
<span class="arithmatex">\(\mathbf{H}\)</span>
 is used to create a Merkle tree to record eight (8) values; 
 <span class="arithmatex">\(\text{V}_{\mathbf{a}}, \text{V}_{\mathbf{b}}, \text{V}_{\mathbf{c}}, \text{V}_{\mathbf{d}}, \text{V}_{\mathbf{e}}, \text{V}_{\mathbf{f}}, \text{V}_{\mathbf{g}}, \text{V}_{\mathbf{h}}\)</span>;</p>
<ol>
<li>Each leaf is nothing but the hash <span class="arithmatex">\(\mathbf{H}(\text{V}_{\mathbf{i}})\)</span> of a particular value <span class="arithmatex">\(\text{V}_{\mathbf{i}}\)</span>, where <br />
<span class="arithmatex">\(\mathbf{ i} \in \{ \mathbf{a}, \mathbf{b}, \mathbf{c}, \mathbf{d}, \mathbf{e}, \mathbf{f}, \mathbf{g}, \mathbf{h} \}\)</span>.</li>
<li>The branches;  <span class="arithmatex">\(\mathbf{B}_{\mathbf{ab}} = \mathbf{H} \big( \mathbf{H}(\text{V}_{\mathbf{a}})\| \mathbf{H}(\text{V}_{\mathbf{b}}) \big)\)</span>,<br />
<span class="arithmatex">\(\mathbf{B}_{\mathbf{cd}} = \mathbf{H} \big( \mathbf{H}(\text{V}_{\mathbf{c}})\| \mathbf{H}(\text{V}_{\mathbf{d}}) \big)\)</span>, 
    <span class="arithmatex">\(\mathbf{B}_{\mathbf{ef}} = \mathbf{H} \big( \mathbf{H}(\text{V}_{\mathbf{e}})\| \mathbf{H}(\text{V}_{\mathbf{f}}) \big)\)</span>,<br />
<span class="arithmatex">\(\mathbf{B}_{\mathbf{gh}} = \mathbf{H} \big( \mathbf{H}(\text{V}_{\mathbf{g}})\| \mathbf{H}(\text{V}_{\mathbf{h}}) \big)\)</span>, <span class="arithmatex">\(\mathbf{B}_{\mathbf{abcd}} = \mathbf{H} \big(\mathbf{B}_{\mathbf{ab}}\| \mathbf{B}_{\mathbf{cd}} \big)\)</span>  and  <span class="arithmatex">\(\mathbf{B}_{\mathbf{efgh}} = \mathbf{H} \big( \mathbf{B}_{\mathbf{ef}}\| \mathbf{B}_{\mathbf{gh}} \big)\)</span>.</li>
<li>The root is  <span class="arithmatex">\(\mathbf{root}_{\mathbf{a..h}} = \mathbf{H} \big(\mathbf{B}_{\mathbf{abcd}}\| \mathbf{B}_{\mathbf{efgh}} \big)\)</span>.</li>
</ol>
<p><img alt="Figure 3: A Merkle Tree Example" src="../fig1-mkl-tree-gen1.png" /></p>
<div align="center"><b> Figure 3: A Merkle Tree Example </b></div>

<p>Leaves that share a parent-node are called <strong><em>siblings</em></strong>. The same terminology applies to branches. For example, <span class="arithmatex">\(\mathbf{B}_{\mathbf{ab}}\)</span> and <span class="arithmatex">\(\mathbf{B}_{\mathbf{cd}}\)</span> are siblings because they are branches of the same parent, <span class="arithmatex">\(\mathbf{B}_{\mathbf{abcd}}\)</span>. Similarly, <span class="arithmatex">\(\mathbf{B}_{\mathbf{efgh}}\)</span> and <span class="arithmatex">\(\mathbf{B}_{\mathbf{abcd}}\)</span> are siblings. </p>
<h3 id="using-keys-to-navigate-a-merkle-tree">Using Keys To Navigate A Merkle Tree</h3>
<p>Keys are used to navigate from the root to the leaves (and backwards).</p>
<p><strong><em>Reading the key</em></strong> starting from <strong><em>the left to the right</em></strong>, and when traversing the tree <strong><em>from the root downwards</em></strong>,</p>
<ul>
<li>
<p>a zero-key-bit "<span class="arithmatex">\(0\)</span>" means "<strong><em>follow the edge going to the left</em></strong>", </p>
</li>
<li>
<p>a key-bit "<span class="arithmatex">\(1\)</span>" means "<strong><em>follow the edge going to the right</em></strong>".</p>
</li>
</ul>
<p>Consider the tree in Figure 1 above, as an example. Suppose one is given the key-value pair <span class="arithmatex">\(( K_{\mathbf{d}} , V_{\mathbf{d}})\)</span>, where <span class="arithmatex">\(K_{\mathbf{d}} = 10010110\)</span>.</p>
<p>The leaf <span class="arithmatex">\(L_{\mathbf{d}}\)</span>, storing the value <span class="arithmatex">\(V_{\mathbf{d}}\)</span>, is located uniquely by using the key, <span class="arithmatex">\(K_{\mathbf{d} } = 10010110\)</span>, as follows;</p>
<ol>
<li>Read the least-significant bit of <span class="arithmatex">\(K_{\mathbf{d}}\)</span>, which is <span class="arithmatex">\(0\)</span>, hence traverse the tree to the left, and reach <span class="arithmatex">\(\mathbf{B_{abcd}}\)</span>.</li>
<li>Then read the second significant key-bit, which is "<span class="arithmatex">\(1\)</span>" in this case. So take the edge going to the right, reaching <span class="arithmatex">\(\mathbf{B_{cd}}\)</span>.</li>
<li>Again, read the next key-bit, which is "<span class="arithmatex">\(1\)</span>", hence follow the edge going to the right, reaching the leaf <span class="arithmatex">\(\mathbf{H}( V_{\mathbf{d}} )\)</span>.</li>
</ol>
<p>Since <span class="arithmatex">\(\mathbf{H}( V_{\mathbf{d}})\)</span> is a leaf and not a branch, and the navigation was correctly done with respect to the given key <span class="arithmatex">\(K_{\mathbf{d}}\)</span>, the <span class="arithmatex">\(\mathbf{H}( V_{\mathbf{d}})\)</span> must be the leaf storing the value <span class="arithmatex">\(V_{\mathbf{d}}\)</span>.</p>
<p>One can similarly "climb" the tree, going in the reverse direction, by using the key-bits of the given key in the reverse order. i.e., Starting with the last key-bit used to reach the leaf and ending with the least-significant bit of the key.</p>
<p>The <strong>tree-address</strong> of the value <span class="arithmatex">\(V_{\mathbf{x}}\)</span>, herein refers to the position of the leaf <span class="arithmatex">\(L_{\mathbf{x}} := \mathbf{H}( V_{\mathbf{x}})\)</span>, denoted by the key-bits used to reach <span class="arithmatex">\(L_{\mathbf{d}}\)</span> but in the reverse order. </p>
<p>In the above example (i.e., The tree in Figure 1), the tree-address of <span class="arithmatex">\(V_{\mathbf{d}}\)</span>  is <code>011</code>.</p>
<h3 id="a-merkle-proof-example">A Merkle Proof Example</h3>
<p>Merkle Trees can be used as commitment schemes. </p>
<p>Here's an example that follows the (key,value)-pair approach used in the zkProver. </p>
<p>Consider the Merkle Tree shown in <a href="">Figure 3</a> above. </p>
<p>If the prover has committed to a value <span class="arithmatex">\(\text{V}_{\mathbf{f}}\)</span> by appending a new leaf <span class="arithmatex">\(\mathbf{H}(\text{V}_{\mathbf{f}})\)</span> to the Merkle Tree as in <a href="">Figure 3</a>, he must then avail the following information, to enable verification of his claim; </p>
<ol>
<li>The Merkle root <span class="arithmatex">\(\mathbf{root}_{\mathbf{a..h}}\)</span>,</li>
<li>The value <span class="arithmatex">\(\text{V}_{\mathbf{f}}\)</span>,</li>
<li>The siblings; <span class="arithmatex">\(\mathbf{H}(\text{V}_{\mathbf{e}})\)</span>, <span class="arithmatex">\(\mathbf{B}_{\mathbf{gh}}\)</span> and <span class="arithmatex">\(\mathbf{B}_{\mathbf{abcd}}\)</span>.</li>
</ol>
<p>Instead of searching through all hash values stored in the tree, the verifier uses only a few hash values of relevant siblings. That is, three (3) in this case.</p>
<p>The verifier then checks the prover's claim by computing the Merkle root as follows;</p>
<p>​   (a) He computes  <span class="arithmatex">\(\mathbf{H}(\text{V}_{\mathbf{f}})\)</span>, which is the hash of the value <span class="arithmatex">\(\text{V}_{\mathbf{f}}\)</span>.</p>
<p>​   (b) Then uses the sibling  <span class="arithmatex">\(\mathbf{H}(\text{V}_{\mathbf{e}})\)</span>  to compute  <span class="arithmatex">\(\mathbf{H} \big( \mathbf{H}(\text{V}_{\mathbf{e}})\|\mathbf{H}(\text{V}_{\mathbf{f}}) \big) =: \tilde{ \mathbf{B}}_{\mathbf{ef}}\)</span>, which should be the same as the branch node <span class="arithmatex">\(\mathbf{B}_{\mathbf{ef}}\)</span>.</p>
<p>(<strong>Note.</strong> The symbol, <code>tilde</code> " <span class="arithmatex">\(\tilde{ }\)</span> ", is used throughout the document to indicate that the computed value, <span class="arithmatex">\(\tilde{\Box}\)</span>, still needs to be checked, or tested to be true.)</p>
<p>​   (c) Next, he computes  <span class="arithmatex">\(\mathbf{H} \big( \tilde{ \mathbf{B}}_{\mathbf{ef}}\|\mathbf{B}_{\mathbf{gh}} \big) =: \tilde{ \mathbf{B}}_{\mathbf{efgh}}\)</span>, corresponding to the branch node <span class="arithmatex">\(\mathbf{B}_{\mathbf{efgh}}\)</span>.</p>
<p>​   (d) Now, uses <span class="arithmatex">\(\mathbf{H} \big( \mathbf{B}_{\mathbf{abcd}}\| \tilde{ \mathbf{B}}_{\mathbf{efgh}} \big) =: \tilde{ \mathbf{root}}_{\mathbf{a..h}}\)</span>.</p>
<p>The Merkle proof is concluded by checking whether <span class="arithmatex">\(\tilde{ \mathbf{root}}_{\mathbf{a\dots h}}\)</span> equals to the publicly known root <span class="arithmatex">\(\mathbf{root}_{\mathbf{a..h}}\)</span>.</p>
<h3 id="building-simplified-binary-sparse-merkle-trees">Building Simplified Binary Sparse Merkle Trees</h3>
<p>Consider key-value pair based binary Sparse Merkle Trees (SMTs). </p>
<p>The focus here is on explaining how to build an SMT that represents a given set of key-value pairs. And, for simplicity sake, key-lengths of 8 bits are assumed.</p>
<p>A NULL or <strong>empty</strong> SMT has a zero root. That is, no key and no value recorded. Similarly, a zero node or NULL node refers to a node that carry no value.</p>
<h4 id="a-binary-smt-with-one-key-value-pair">A Binary SMT With One Key-Value Pair</h4>
<p>A binary SMT with a <strong>single key-value pair</strong> <span class="arithmatex">\((K_{\mathbf{a}}, \text{V}_{\mathbf{a}})\)</span>, is built as follows. </p>
<p>Suppose that the key, <span class="arithmatex">\(K_{\mathbf{a}} = 11010110\)</span>. In order to build a binary SMT with this single key-value <span class="arithmatex">\((K_{\mathbf{a}}, \text{V}_{\mathbf{a}})\)</span>,</p>
<p>(a) One computes the hash <span class="arithmatex">\(\mathbf{H}( \text{V}_{\mathbf{a}})\)</span> of the value <span class="arithmatex">\(\text{V}_{\mathbf{a}}\)</span>,</p>
<p>(b) Sets the leaf <span class="arithmatex">\(\mathbf{L}_{\mathbf{a}} := \mathbf{H}( \text{V}_{\mathbf{a}})\)</span>,</p>
<p>(c) Sets the sibling leaf as a NULL leaf, simply represented as "<span class="arithmatex">\(\mathbf{0}\)</span>", </p>
<p>(d) Computes the root as  <span class="arithmatex">\(\mathbf{root}_{a0} = \mathbf{H}(\mathbf{L}_{\mathbf{a}} \| \mathbf{0} )\)</span>, with the leaf <span class="arithmatex">\(\mathbf{L}_{\mathbf{a}}\)</span> on the left because the <span class="arithmatex">\(\text{lsb}(K_{\mathbf{a}}) = 0\)</span>. That is, between the two edges leading up to the root, the leaf <span class="arithmatex">\(\mathbf{L}_{\mathbf{a}}\)</span> is on the left edge, while the NULL leaf "<span class="arithmatex">\(\mathbf{0}\)</span>" is on the right.</p>
<p>See, Figure 4 below, for the SMT representing the single key-value pair <span class="arithmatex">\((K_{\mathbf{a}}, \text{V}_{\mathbf{a}})\)</span>, where  <span class="arithmatex">\(K_{\mathbf{a}} = 11010110\)</span>.</p>
<p><img alt="Figure 4: A Single key-value pair SMT" src="../fig3-sngl-kv-eg.png" /></p>
<div align="center"><b> Figure 4: A Single key-value pair SMT </b></div>

<p>Note that the last nodes in binary SMT branches are generally either leaves or zero-nodes. </p>
<p>In the case where the least-significant bit, <strong>lsb of <span class="arithmatex">\(K_{\mathbf{a}}\)</span> is <span class="arithmatex">\(1\)</span></strong>, the SMT with a single key-value pair <span class="arithmatex">\((K_{\mathbf{a}}, \text{V}_{\mathbf{a}})\)</span> would be a mirror image of what is seen in Figure 3. And its root,  <span class="arithmatex">\(\mathbf{root}_{0a} = \mathbf{H}( \mathbf{0}\| \mathbf{L}_{\mathbf{a}}  ) \neq \mathbf{root}_{a0}\)</span> because <span class="arithmatex">\(\mathbf{H}\)</span> is a collision-resistant hash function.</p>
<p>This example also explains why we need a zero node. Since all trees used in our design are <strong>binary</strong> SMTs, a zero node is used as a default sibling for computing the parent node. This helps to differentiate between roots (also between parent nodes) because a root node actually identifies an SMT. Therefore, it is crucial to distinguish between  <span class="arithmatex">\(\mathbf{root}_{a0} = \mathbf{H}(\mathbf{L}_{\mathbf{a}} \| \mathbf{0} )\)</span> and <span class="arithmatex">\(\mathbf{root}_{0a} = \mathbf{H}( \mathbf{0}\| \mathbf{L}_{\mathbf{a}})\)</span> because they represent two distinct trees.</p>
<h4 id="binary-smts-with-two-key-value-pairs">Binary SMTs With Two Key-Value Pairs</h4>
<p>Consider now SMTs with <strong>two key-value pairs</strong>, <span class="arithmatex">\((K_{\mathbf{a}}, \text{V}_{\mathbf{a}})\)</span> and <span class="arithmatex">\((K_{\mathbf{b}}, \text{V}_{\mathbf{b}})\)</span>. </p>
<p>There are three distinct cases of how corresponding SMTs can be built, each determined by the keys, <span class="arithmatex">\(K_{\mathbf{a}}\)</span> and <span class="arithmatex">\(K_{\mathbf{b}}\)</span>.</p>
<p><strong>Case 1</strong>: The keys are such that the <span class="arithmatex">\(\text{lsb}(K_{\mathbf{a}}) = 0\)</span> and the <span class="arithmatex">\(\text{lsb}(K_{\mathbf{b}}) = 1\)</span>.</p>
<p>Suppose that the keys are given as, <span class="arithmatex">\(K_{\mathbf{a}} = 11010110\)</span> and <span class="arithmatex">\(K_{\mathbf{b}} = 11010101\)</span>. </p>
<p>To build a binary SMT with this two key-values, <span class="arithmatex">\((K_{\mathbf{a}}, \text{V}_{\mathbf{a}})\)</span> and <span class="arithmatex">\((K_{\mathbf{b}}, \text{V}_{\mathbf{b}})\)</span>,</p>
<p>(a) One computes the hashes, <span class="arithmatex">\(\mathbf{H}(\text{V}_{\mathbf{a}})\)</span> and <span class="arithmatex">\(\mathbf{H}( \text{V}_{\mathbf{b}})\)</span> of the values, <span class="arithmatex">\(\text{V}_{\mathbf{a}}\)</span> and <span class="arithmatex">\(\text{V}_{\mathbf{b}}\)</span> , respectively,</p>
<p>(b) Sets the leaves, <span class="arithmatex">\(\mathbf{L}_{\mathbf{a}} := \mathbf{H}( \text{V}_{\mathbf{a}})\)</span> and <span class="arithmatex">\(\mathbf{L}_{\mathbf{b}} := \mathbf{H}( \text{V}_{\mathbf{b}})\)</span>,</p>
<p>(c) Checks if the <span class="arithmatex">\(\text{lsb}(K_{\mathbf{a}})\)</span> differs from the <span class="arithmatex">\(\text{lsb}(K_{\mathbf{b}})\)</span>,</p>
<p>(d) Since the <span class="arithmatex">\(\text{lsb}(K_{\mathbf{a}}) = 0\)</span> and the <span class="arithmatex">\(\text{lsb}(K_{\mathbf{b}}) = 1\)</span>, it means <strong><em>the two leaves can be siblings</em></strong>,</p>
<p>(e) One can then compute the root as, <span class="arithmatex">\(\mathbf{root}_{\mathbf{ab}} = \mathbf{H}(\mathbf{L}_{\mathbf{a}} \| \mathbf{L}_{\mathbf{b}})\)</span>. </p>
<p>​       Note that, the leaf <span class="arithmatex">\(\mathbf{L}_{\mathbf{a}}\)</span> is on the left because the <span class="arithmatex">\(\text{lsb}(K_{\mathbf{a}}) = 0\)</span>, but <span class="arithmatex">\(\mathbf{L}_{\mathbf{b}}\)</span> is on the right because the <span class="arithmatex">\(\text{lsb}(K_{\mathbf{b}}) = 1\)</span>. That is, between <em>the two edges leading up to the <span class="arithmatex">\(\mathbf{root}_{\mathbf{ab}}\)</span></em>, the leaf <span class="arithmatex">\(\mathbf{L}_{\mathbf{a}}\)</span> must be on the edge from the left, while <span class="arithmatex">\(\mathbf{L}_{\mathbf{b}}\)</span> is on the edge from the right.</p>
<p>See, Figure 5(a) below, for the SMT representing the two key-value pairs <span class="arithmatex">\((K_{\mathbf{a}}, \text{V}_{\mathbf{a}})\)</span> and <span class="arithmatex">\((K_{\mathbf{b}}, \text{V}_{\mathbf{b}})\)</span>, where  <span class="arithmatex">\(K_{\mathbf{a}} = 11010110\)</span> and <span class="arithmatex">\(K_{\mathbf{b}} = 11010101\)</span>.</p>
<p><img alt="Figure 5(a): Two key-value pairs SMT - Case 1" src="../fig4a-mpt-2kv-eg.png" /></p>
<div align="center"><b> Figure 5(a): Two key-value pairs SMT - Case 1 </b></div>

<p><strong>Case 2</strong>: Both keys end with the same key-bit. That is, the <span class="arithmatex">\(\text{lsb}(K_{\mathbf{a}}) = \text{lsb}(K_{\mathbf{b}})\)</span>, but their second least-significant bits differ.</p>
<p>Suppose that the two keys are given as, <span class="arithmatex">\(K_{\mathbf{a}} = 11010100\)</span> and <span class="arithmatex">\(K_{\mathbf{b}} = 11010110\)</span>. </p>
<p>To build a binary SMT with this two key-values, <span class="arithmatex">\((K_{\mathbf{a}}, \text{V}_{\mathbf{a}})\)</span> and <span class="arithmatex">\((K_{\mathbf{b}}, \text{V}_{\mathbf{b}})\)</span>;</p>
<p>(a) One computes the hashes, <span class="arithmatex">\(\mathbf{H}(\text{V}_{\mathbf{a}})\)</span> and <span class="arithmatex">\(\mathbf{H}( \text{V}_{\mathbf{b}})\)</span> of the values, <span class="arithmatex">\(\text{V}_{\mathbf{a}}\)</span> and <span class="arithmatex">\(\text{V}_{\mathbf{b}}\)</span> , respectively.</p>
<p>(b) Sets the leaves, <span class="arithmatex">\(\mathbf{L}_{\mathbf{a}} := \mathbf{H}( \text{V}_{\mathbf{a}})\)</span> and <span class="arithmatex">\(\mathbf{L}_{\mathbf{b}} := \mathbf{H}( \text{V}_{\mathbf{b}})\)</span>.</p>
<p>(c) Checks if the <span class="arithmatex">\(\text{lsb}(K_{\mathbf{a}})\)</span> differs from the <span class="arithmatex">\(\text{lsb}(K_{\mathbf{b}})\)</span>. Since the <span class="arithmatex">\(\text{lsb}(K_{\mathbf{a}}) = 0\)</span> and the <span class="arithmatex">\(\text{lsb}(K_{\mathbf{b}}) = 0\)</span>, it means <strong><em>the two leaves cannot be siblings</em></strong> at this position because it would otherwise mean they share the same tree-address <code>0</code>, which is not allowed.</p>
<p>(d) One, therefore, continues to check if the second least-significant bits of  <span class="arithmatex">\(K_{\mathbf{a}}\)</span> and <span class="arithmatex">\(K_{\mathbf{b}}\)</span> differ. Since the <span class="arithmatex">\(\text{second lsb}(K_{\mathbf{a}}) = 0\)</span> and the <span class="arithmatex">\(\text{second lsb}(K_{\mathbf{b}}) = 1\)</span>, it means <strong><em>the two leaves <span class="arithmatex">\(\mathbf{L}_{\mathbf{a}}\)</span> and <span class="arithmatex">\(\mathbf{L}_{\mathbf{b}}\)</span> can be siblings</em></strong> at their respective tree-addresses, <code>00</code> and <code>10</code>.</p>
<p>(e) Next is to compute the hash <span class="arithmatex">\(\mathbf{H}(\mathbf{L}_{\mathbf{a}} \| \mathbf{L}_{\mathbf{b}})\)</span> and set it as the branch <span class="arithmatex">\(\mathbf{B}_{\mathbf{ab}} := \mathbf{H}(\mathbf{L}_{\mathbf{a}} \| \mathbf{L}_{\mathbf{b}})\)</span> at the tree-address <code>0</code>. Note that the leaf <span class="arithmatex">\(\mathbf{L}_{\mathbf{a}}\)</span> is on the left because the <span class="arithmatex">\(\text{second  lsb}(K_{\mathbf{a}}) = 0\)</span>, while <span class="arithmatex">\(\mathbf{L}_{\mathbf{b}}\)</span> is on the right because the <span class="arithmatex">\(\text{second  lsb}(K_{\mathbf{b}}) = 1\)</span>.</p>
<p>(f) The branch <span class="arithmatex">\(\mathbf{B}_{\mathbf{ab}} := \mathbf{H}(\mathbf{L}_{\mathbf{a}} \| \mathbf{L}_{\mathbf{b}})\)</span> needs a sibling. Since all the values, <span class="arithmatex">\(\text{V}_{\mathbf{a}}\)</span> and <span class="arithmatex">\(\text{V}_{\mathbf{b}}\)</span>, are already represented in the tree at <span class="arithmatex">\(\mathbf{L}_{\mathbf{a}}\)</span> and <span class="arithmatex">\(\mathbf{L}_{\mathbf{b}}\)</span>, respectively, one therefore sets a NULL leaf "<span class="arithmatex">\(\mathbf{0}\)</span>" as the sibling leaf to <span class="arithmatex">\(\mathbf{B}_{\mathbf{ab}}\)</span>.</p>
<p>(g) As a result, it is possible to compute the root as, <span class="arithmatex">\(\mathbf{root}_{\mathbf{ab0}} = \mathbf{H}(\mathbf{B}_{\mathbf{ab}} \| \mathbf{0})\)</span>. Note that, the branch <span class="arithmatex">\(\mathbf{B}_{\mathbf{ab}}\)</span> is on the left because the <span class="arithmatex">\(\text{lsb}(K_{\mathbf{a}}) = 0\)</span>, and <span class="arithmatex">\(\mathbf{0}\)</span> must therefore be on the right. That is, between <em>the two edges leading up to the <span class="arithmatex">\(\mathbf{root}_{\mathbf{ab0}}\)</span></em>, the branch <span class="arithmatex">\(\mathbf{B}_{\mathbf{ab}}\)</span> must be on the edge from the left, while <span class="arithmatex">\(\mathbf{0}\)</span> is on the edge from the right.</p>
<p>See, Figure 5(b) below, depicting the SMT representing the two key-value pairs <span class="arithmatex">\((K_{\mathbf{a}}, \text{V}_{\mathbf{a}})\)</span> and <span class="arithmatex">\((K_{\mathbf{b}}, \text{V}_{\mathbf{b}})\)</span>, where  <span class="arithmatex">\(K_{\mathbf{a}} = 11010100\)</span> and <span class="arithmatex">\(K_{\mathbf{b}} = 11010110\)</span>. </p>
<p><img alt="Figure 5(b): Two key-value pairs SMT - Case 2" src="../fig4b-mpt-2kv-eg.png" /></p>
<div align="center"><b> Figure 5(b): Two key-value pairs SMT - Case 2 </b></div>

<p><strong>Case 3</strong>: The first two least-significant bits of both keys are the same, but their third least-significant bits differ.</p>
<p>Suppose that the two keys are given as, <span class="arithmatex">\(K_{\mathbf{a}} = 11011000\)</span> and <span class="arithmatex">\(K_{\mathbf{b}} = 10010100\)</span>. The process for building a binary SMT with this two key-values, <span class="arithmatex">\((K_{\mathbf{a}}, \text{V}_{\mathbf{a}})\)</span> and <span class="arithmatex">\((K_{\mathbf{b}}, \text{V}_{\mathbf{b}})\)</span> is the same as in Case 2;</p>
<p>(a) One computes the hashes, <span class="arithmatex">\(\mathbf{H}(\text{V}_{\mathbf{a}})\)</span> and <span class="arithmatex">\(\mathbf{H}( \text{V}_{\mathbf{b}})\)</span> of the values, <span class="arithmatex">\(\text{V}_{\mathbf{a}}\)</span> and <span class="arithmatex">\(\text{V}_{\mathbf{b}}\)</span> , respectively.</p>
<p>(b) Sets the leaves, <span class="arithmatex">\(\mathbf{L}_{\mathbf{a}} := \mathbf{H}( \text{V}_{\mathbf{a}})\)</span> and <span class="arithmatex">\(\mathbf{L}_{\mathbf{b}} := \mathbf{H}( \text{V}_{\mathbf{b}})\)</span>.</p>
<p>(c) Checks if the <span class="arithmatex">\(\text{lsb}(K_{\mathbf{a}})\)</span> differs from the <span class="arithmatex">\(\text{lsb}(K_{\mathbf{b}})\)</span>. Since the <span class="arithmatex">\(\text{lsb}(K_{\mathbf{a}}) = 0\)</span> and the <span class="arithmatex">\(\text{lsb}(K_{\mathbf{b}}) = 0\)</span>, it means <strong><em>the two leaves cannot be siblings</em></strong> at this position as it would otherwise mean they share the same tree-address <code>0</code>, which is not allowed.</p>
<p>(d) Next verifier coninues to check if the second least-significant bits of <span class="arithmatex">\(K_{\mathbf{a}}\)</span> and <span class="arithmatex">\(K_{\mathbf{b}}\)</span> differ. Since the <span class="arithmatex">\(\text{second lsb}(K_{\mathbf{a}}) = 0\)</span>  and the <span class="arithmatex">\(\text{second lsb}(K_{\mathbf{b}}) = 0\)</span>, it means <strong><em>the two leaves cannot be siblings</em></strong> at this position, because it would otherwise mean they share the same tree-address <code>00</code>, which is not allowed.</p>
<p>(e) Once again he checks if the third least-significant bits of <span class="arithmatex">\(K_{\mathbf{a}}\)</span> and <span class="arithmatex">\(K_{\mathbf{b}}\)</span> differ. Since the <span class="arithmatex">\(\text{third lsb}(K_{\mathbf{a}}) = 0\)</span> and the <span class="arithmatex">\(\text{third  lsb}(K_{\mathbf{b}}) = 1\)</span>, it means <strong><em>the two leaves <span class="arithmatex">\(\mathbf{L}_{\mathbf{a}}\)</span> and <span class="arithmatex">\(\mathbf{L}_{\mathbf{b}}\)</span> can be siblings</em></strong> at their respective tree-addresses, <code>000</code> and <code>100</code>.</p>
<p>(f) One then computes the hash <span class="arithmatex">\(\mathbf{H}(\mathbf{L}_{\mathbf{a}} \| \mathbf{L}_{\mathbf{b}})\)</span>, and sets it as the branch <span class="arithmatex">\(\mathbf{B}_{\mathbf{ab}} := \mathbf{H}(\mathbf{L}_{\mathbf{a}} \| \mathbf{L}_{\mathbf{b}})\)</span> at the tree-address <code>00</code>. The leaf <span class="arithmatex">\(\mathbf{L}_{\mathbf{a}}\)</span> is on the left because the third <span class="arithmatex">\(\text{lsb}(K_{\mathbf{a}}) = 0\)</span>, while <span class="arithmatex">\(\mathbf{L}_{\mathbf{b}}\)</span> is on the right because the third <span class="arithmatex">\(\text{lsb}(K_{\mathbf{b}}) = 1\)</span>.</p>
<p>(g) The branch <span class="arithmatex">\(\mathbf{B}_{\mathbf{ab}} := \mathbf{H}(\mathbf{L}_{\mathbf{a}} \| \mathbf{L}_{\mathbf{b}})\)</span> needs a sibling. Since all the values, <span class="arithmatex">\(\text{V}_{\mathbf{a}}\)</span> and <span class="arithmatex">\(\text{V}_{\mathbf{b}}\)</span> , are already represented in the tree at <span class="arithmatex">\(\mathbf{L}_{\mathbf{a}}\)</span> and <span class="arithmatex">\(\mathbf{L}_{\mathbf{b}}\)</span>, respectively, one therefore sets a NULL leaf "<span class="arithmatex">\(\mathbf{0}\)</span>" as the sibling leaf to <span class="arithmatex">\(\mathbf{B}_{\mathbf{ab}}\)</span>.</p>
<p>(h) One can now compute the hash <span class="arithmatex">\(\mathbf{H}(\mathbf{B}_{\mathbf{ab}} \| \mathbf{0})\)</span>, and set it as the branch <span class="arithmatex">\(\mathbf{B}_{\mathbf{ab0}} := \mathbf{H}(\mathbf{B}_{\mathbf{ab}} \| \mathbf{0})\)</span> at the tree-address <code>0</code>. The hash is computed with the branch <span class="arithmatex">\(\mathbf{B}_{\mathbf{ab}}\)</span> on the left because the second lsb of both keys, <span class="arithmatex">\(K_{\mathbf{a}}\)</span> and <span class="arithmatex">\(K_{\mathbf{b}}\)</span>, equals <span class="arithmatex">\(0\)</span>. Therefore the NULL leaf "<span class="arithmatex">\(\mathbf{0}\)</span>" must be on the right as an argument to the hash.</p>
<p>(i) The branch <span class="arithmatex">\(\mathbf{B}_{\mathbf{ab0}} := \mathbf{H}(\mathbf{B}_{\mathbf{ab}} \| \mathbf{0})\)</span> also needs a sibling. For the same reason given above, one sets a NULL leaf "<span class="arithmatex">\(\mathbf{0}\)</span>" as the sibling leaf to <span class="arithmatex">\(\mathbf{B}_{\mathbf{ab0}}\)</span>. </p>
<p>(j) Now, one is able to compute the root as, <span class="arithmatex">\(\mathbf{root}_{\mathbf{ab00}} = \mathbf{H}(\mathbf{B}_{\mathbf{ab0}} \| \mathbf{0})\)</span>. Note that the hash is computed with the branch <span class="arithmatex">\(\mathbf{B}_{\mathbf{ab0}}\)</span> on the left because the lsb of both keys, <span class="arithmatex">\(K_{\mathbf{a}}\)</span> and <span class="arithmatex">\(K_{\mathbf{b}}\)</span>, equals <span class="arithmatex">\(0\)</span>. That is, between <em>the two edges leading up to the <span class="arithmatex">\(\mathbf{root}_{\mathbf{ab00}}\)</span></em>, the branch <span class="arithmatex">\(\mathbf{B}_{\mathbf{ab0}}\)</span> must be on the edge from the left, while "<span class="arithmatex">\(\mathbf{0}\)</span>" is on the edge from the right.</p>
<p>See, Figure 5(c) below, depicting the SMT representing the two key-value pairs <span class="arithmatex">\((K_{\mathbf{a}}, \text{V}_{\mathbf{a}})\)</span> and <span class="arithmatex">\((K_{\mathbf{b}}, \text{V}_{\mathbf{b}})\)</span>, where  <span class="arithmatex">\(K_{\mathbf{a}} = 11011000\)</span> and <span class="arithmatex">\(K_{\mathbf{b}} = 10010100\)</span>.</p>
<p><img alt="Figure 5(c): Two key-value pairs SMT - Case 3" src="../fig4c-mpt-2kv-eg.png" /></p>
<div align="center"><b> Figure 5(c): Two key-value pairs SMT - Case 3 </b></div>

<p>There are several other SMTs of two key-value pairs <span class="arithmatex">\((K_{\mathbf{x}}, \text{V}_{\mathbf{x}})\)</span> and <span class="arithmatex">\((K_{\mathbf{z}}, \text{V}_{\mathbf{z}})\)</span> that can be constructed depending on how long are the strings of the common least-significant bits between <span class="arithmatex">\(K_{\mathbf{x}}\)</span> and <span class="arithmatex">\(K_{\mathbf{z}}\)</span>.</p>
<p>In general, when building an SMT, leaves of key-value pairs with the same least-significant key-bits share the same "navigational path" only until any of the corresponding key-bits differ. These common strings of key-bits dictate where the leaf storing the corresponding value is located in the tree.</p>
<h3 id="a-few-more-concepts-about-binary-smts">A Few More Concepts About Binary SMTs</h3>
<p>In here are a few more concepts needed in understanding our specific design of the zkProver storage using binary SMTs. These concepts also help in elucidating how keys influence the shape of binary SMTs.</p>
<p>First is the level of a leaf. </p>
<p>The <strong>level of a leaf</strong>, <span class="arithmatex">\(\mathbf{L}_{\mathbf{x}}\)</span>, in a binary SMT is defined as the number of edges one traverses when navigating  from the root to the leaf. Denote the level of the leaf <span class="arithmatex">\(\mathbf{L_x}\)</span> by  <span class="arithmatex">\(\text{lvl}(\mathbf{L_x})\)</span>.</p>
<h4 id="example-1-leaf-levels">Example 1. <em>Leaf Levels</em></h4>
<p>Consider Figure 6 below, for an SMT storing seven (7) key-value pairs, built by following the principles explained in the foregoing subsection;</p>
<div class="arithmatex">\[\begin{aligned}
(\mathbf{K}_{\mathbf{a}} , V_{\mathbf{a}}),\ \ (\mathbf{K}_{\mathbf{b}} , V_{\mathbf{b}}),\ \ 
(\mathbf{K}_{\mathbf{c}} , V_{\mathbf{c}}),\ \ (\mathbf{K}_{\mathbf{c}}, V_{\mathbf{c}}),\\ 
(\mathbf{K}_{\mathbf{d}}, V_{\mathbf{d}}),\ \ 
(\mathbf{K}_{\mathbf{e}}, V_{\mathbf{e}}),\ \ 
(\mathbf{K}_{\mathbf{f}}, V_{\mathbf{f}})\ \ {\text{and}}\ \ (\mathbf{K}_{\mathbf{g}} , V_{\mathbf{g}})
\end{aligned}\]</div>
<p>where the keys are,</p>
<div class="arithmatex">\[\begin{aligned}
K_{\mathbf{a}} = 10101100, K_{\mathbf{b}} = 10010010, K_{\mathbf{c}} = 10001010, &amp;K_{\mathbf{d}} = 11100110,\\ K_{\mathbf{e}} = 11110101, K_{\mathbf{f}} = 10001011, K_{\mathbf{g}} = 00011111.
\end{aligned}\]</div>
<p>The leaf levels are as follows;</p>
<p><span class="arithmatex">\(\text{lvl}(\mathbf{L}_{\mathbf{a}}) = 2\)</span>, <span class="arithmatex">\(\text{lvl}(\mathbf{L}_{\mathbf{b}}) = 4\)</span>, <span class="arithmatex">\(\text{lvl}(\mathbf{L}_{\mathbf{c}}) = 4\)</span>, <span class="arithmatex">\(\text{lvl}(\mathbf{L}_{\mathbf{d}}) = 3\)</span>,
<span class="arithmatex">\(\text{lvl}(\mathbf{L}_{\mathbf{e}}) = 2\)</span>, <span class="arithmatex">\(\text{lvl}(\mathbf{L}_{\mathbf{f}}) = 3\)</span> and <span class="arithmatex">\(\text{lvl}(\mathbf{L}_{\mathbf{g}}) = 3\)</span>.</p>
<p><img alt="Figure 6: An SMT of 7 key-value pairs" src="../fig2-mpt-gen-eg.png" /></p>
<div align="center"><b> Figure 6: An SMT of 7 key-value pairs </b></div>

<p>As illustrated, in the above subsections, keys basically determine the shape of the SMT. They dictate where respective leaves must be placed when building the SMT. </p>
<p>The main determining factor of the SMT shape is in fact the common key-bits among the keys. For instance, the reason why the leaves <span class="arithmatex">\(\mathbf{L}_{\mathbf{b}}\)</span> and <span class="arithmatex">\(\mathbf{L}_{\mathbf{c}}\)</span> have the largest leaf level <span class="arithmatex">\(4\)</span> is because the two leaves have the longest string of common key-bits "<span class="arithmatex">\(010\)</span>" in the SMT of Figure 6 above.</p>
<p>This explains why different leaves in SMTs can have different levels.</p>
<p>The <strong>height of a Merkle Tree</strong> refers to the largest number of edges traversed when navigating from the root to any leaf. Since all leaves are of the same level in Merkle Trees, the concept of a <strong>height</strong> coincide with that of the <strong>level of a leaf</strong> for Merkle Trees.</p>
<p>But this is not the case for SMTs. Since leaf levels differ from one leaf to another in SMTs, the height of an SMT is not the same as the leaf level.</p>
<p>Rather, the <strong>height of an SMT</strong> is defined as the largest leaf level among the various leaf levels of leaves on the SMT. For instance, <em>the height of the SMT</em> depicted in Figure 6 above, is <span class="arithmatex">\(4\)</span>. </p>
<p>Now, since all keys have the same fixed key-length, they not only influence SMT leaf levels and shapes, but also restrict SMT heights to the fixed key-length. The maximum height of an SMT is the maximum key-length imposed on all keys.</p>
<h4 id="the-remaining-key">The Remaining Key</h4>
<p>In a general Sparse Merkle Tree (SMT) values are stored at their respective leaf-nodes. </p>
<p>But a leaf node <span class="arithmatex">\(\mathbf{L}_{\mathbf{x}}\)</span> not only stores a value, <span class="arithmatex">\(V_{\mathbf{x}}\)</span> , but also the key-bits that are left unused in the navigation from the root to <span class="arithmatex">\(\mathbf{L}_{\mathbf{x}}\)</span>. These unused key-bits are called <strong>the remaining key</strong>, and are denoted by <span class="arithmatex">\(\text{RK}_{\mathbf{x}}\)</span> for the leaf node <span class="arithmatex">\(\mathbf{L}_{\mathbf{x}}\)</span>.</p>
<h4 id="example-2-remaining-keys">Example 2. <em>Remaining Keys</em></h4>
<p>Consider again the SMT of the 7 key-value pairs depicted in Figure 6 above. </p>
<p>The remaining keys of each of the 7 leaves in the SMT are as follows; </p>
<p><span class="arithmatex">\(\text{RK}_{\mathbf{a}} = 110101\)</span>,  <span class="arithmatex">\(\text{RK}_{\mathbf{b}} = 1001\)</span>,  <span class="arithmatex">\(\text{RK}_{\mathbf{c}} = 0001\)</span>,  <span class="arithmatex">\(\text{RK}_{\mathbf{d}} = 00111\)</span>,  <span class="arithmatex">\(\text{RK}_{\mathbf{e}} = 101111\)</span>,  <span class="arithmatex">\(\text{RK}_{\mathbf{f}} = 10001\)</span>  and  <span class="arithmatex">\(\text{RK}_{\mathbf{g}} = 11000\)</span>.</p>
<h3 id="the-fake-leaf-attack">The Fake-Leaf Attack</h3>
<p>Note that the above simplified design of binary SMTs, based on key-value pairs, presents some problems.</p>
<p>The characteristic of binary SMTs having leaves at different levels can be problematic to verifiers, especially when carrying out a simple Merkle proof. </p>
<h4 id="scenario-a-fake-smt-leaf">Scenario A: Fake SMT Leaf</h4>
<p>What if the verifier is presented with a fake leaf?</p>
<p>Consider Figure 7 below, showing a binary SMT with a branch <span class="arithmatex">\(\mathbf{{B}_{ab}}\)</span> and its children <span class="arithmatex">\(\mathbf{L_{a}}\)</span> and <span class="arithmatex">\(\mathbf{L_{b}}\)</span> hidden from the verifier's sight.</p>
<p>That is, suppose the verifier is provided with the following information;</p>
<ul>
<li>The key-value <span class="arithmatex">\((K_{\mathbf{fk}}, V_\mathbf{{fk}})\)</span>, where <span class="arithmatex">\(K_{\mathbf{fk}} = 11010100\)</span> and <span class="arithmatex">\(V_{\mathbf{fk}} = \mathbf{L_{a}} \| \mathbf{L_{b}}\)</span>.</li>
<li>The root  <span class="arithmatex">\(\mathbf{{root}_{ab..f}}\)</span> , the number of levels to root, and the siblings <span class="arithmatex">\(\mathbf{{S}_{\mathbf{cd}}}\)</span> and <span class="arithmatex">\(\mathbf{{S}_{\mathbf{ef}}}\)</span>.</li>
</ul>
<p>That is, the Attacker claims that some <span class="arithmatex">\(V_{\mathbf{fk}}\)</span> is stored at <span class="arithmatex">\(\mathbf{L_{fk}} := \mathbf{{B}_{ab}}\)</span>.</p>
<p>Verifier is unaware that <span class="arithmatex">\(V_{\mathbf{fk}}\)</span> is in fact the concatenated value of the hidden real leaves, <span class="arithmatex">\(\mathbf{L_{a}}\)</span> and <span class="arithmatex">\(\mathbf{L_{b}}\)</span>, that are children of the <em>supposed</em> leaf <span class="arithmatex">\(\mathbf{L_{fk}}\)</span>. i.e., Verifier does not know that leaf <span class="arithmatex">\(\mathbf{L_{fk}}\)</span> is in fact a branch.</p>
<p><img alt="Figure 7: MPT - Fake Leaf Attack" src="../fig6-fake-leaf-eg1.png" /></p>
<div align="center"><b> Figure 7: MPT - Fake Leaf Attack </b></div>

<p>So then, the verifier being unaware that <span class="arithmatex">\(\mathbf{L_{fk}}\)</span> is not a properly constructed leaf, starts verification as follows; </p>
<ol>
<li>He uses the key <span class="arithmatex">\(K_{\mathbf{fk}}\)</span> to navigate the tree until locating the supposed leaf <span class="arithmatex">\(\mathbf{L_{fk}}\)</span>.</li>
<li>He computes <span class="arithmatex">\(\mathbf{H}(V_{\mathbf{fk}})\)</span> and sets it as 
    <span class="arithmatex">\(\tilde{\mathbf{L}}_{\mathbf{fk}} := \mathbf{H}(V_{\mathbf{fk}})\)</span>. </li>
<li>Then takes the sibling <span class="arithmatex">\(\mathbf{{S}_{\mathbf{cd}}}\)</span> and calculates<br />
<span class="arithmatex">\(\tilde{ \mathbf{B}}_{\mathbf{fkcd}} = \mathbf{H} \big( \tilde{\mathbf{L}}_{\mathbf{fk}} \| \mathbf{S}_{\mathbf{cd}}  \big)\)</span>. </li>
<li>And then, uses <span class="arithmatex">\(\tilde{ \mathbf{B}}_{\mathbf{fkcd}}\)</span> to compute the root,  <span class="arithmatex">\(\tilde{ \mathbf{root}}_{\mathbf{ab..f}} = \mathbf{H} \big( \tilde{ \mathbf{B}}_{\mathbf{fkcd}}\| \mathbf{S}_{\mathbf{ef}} \big)\)</span>.</li>
</ol>
<p>The question is: "Does the fake leaf <span class="arithmatex">\(\mathbf{L_{fk}}\)</span> pass the verifier's Merkle proof or not?" Or, equivalently: "Is <span class="arithmatex">\(\tilde{ \mathbf{root}}_{\mathbf{ab..f}}\)</span> equal to <span class="arithmatex">\(\mathbf{root}_{\mathbf{ab..f}}\)</span>?"</p>
<p>Since the actual branch <span class="arithmatex">\(\mathbf{{B}_{ab}}\)</span> is by construction the hash, 
<span class="arithmatex">\(\mathbf{H}(\mathbf{L_{a}} \| \mathbf{L_{b}})\)</span>, then 
<span class="arithmatex">\(\mathbf{{B}_{ab}} = \tilde{\mathbf{L}}_{\mathbf{fk}}\)</span>. 
The parent branch <span class="arithmatex">\({\mathbf{B}}_{\mathbf{abcd}}\)</span> also, being constructed as the hash, 
<span class="arithmatex">\(\mathbf{H} \big( \mathbf{B}_{\mathbf{ab}}\| { \mathbf{S}}_{\mathbf{cd}} \big)\)</span>, should be equal to <span class="arithmatex">\(\mathbf{H} \big( \tilde{\mathbf{L}}_{\mathbf{fk}} \| \mathbf{S}_{\mathbf{cd}}  \big)  = \tilde{ \mathbf{B}}_{\mathbf{fkcd}}\)</span>. As a result, <span class="arithmatex">\(\mathbf{root}_{\mathbf{ab..f}} = \mathbf{H} \big(  {\mathbf{B}}_{\mathbf{abcd}} \| \mathbf{S}_{\mathbf{ef}} \big) = \mathbf{H} \big( \tilde{ \mathbf{B}}_{\mathbf{fkcd}}\| \mathbf{S}_{\mathbf{ef}} \big) = \tilde{ \mathbf{root}}_{\mathbf{ab..f}}\)</span>. </p>
<p>Therefore, the fake leaf <span class="arithmatex">\(\mathbf{L_{fk}}\)</span> passes the Merkle proof. </p>
<h4 id="solution-to-the-fake-leaf-attack">Solution To The Fake-Leaf Attack</h4>
<p>In order to circumvent the Fake-Leaf Attack we modify how the binary SMTs are built.</p>
<p>Here's <strong><em>the trick</em></strong>: When building binary SMTs, differentiate between how leaves are hashed and how branches are hashed.</p>
<p>That is, use two different hash functions; one hash function to hash leaves, denote it by <span class="arithmatex">\(\mathbf{H}_{\mathbf{leaf}}\)</span>, and the other function for hashing non-leaf nodes, denote it by <span class="arithmatex">\(\mathbf{H}_{\mathbf{noleaf}}\)</span>.</p>
<p><strong>How does this prevent the Fake-Leaf Attack?</strong></p>
<p>Reconsider now, the Scenario A, given above. </p>
<p>Recall that the Attacker provides the following;</p>
<ul>
<li>The key-value <span class="arithmatex">\((K_{\mathbf{fk}}, V_\mathbf{{fk}})\)</span>, where <span class="arithmatex">\(K_{\mathbf{fk}} = 11010100\)</span> and <span class="arithmatex">\(V_{\mathbf{fk}} = \mathbf{L_{a}} \| \mathbf{L_{b}}\)</span>.</li>
<li>The root  $ \mathbf{{root}_{ab..f}}$ , the number of levels to root, and the siblings  <span class="arithmatex">\(\mathbf{{S}_{\mathbf{cd}}}\)</span>  and  <span class="arithmatex">\(\mathbf{{S}_{\mathbf{ef}}}\)</span>.</li>
</ul>
<p>The verifier suspecting no foul, uses <span class="arithmatex">\(K_{\mathbf{fk}} = 11010100\)</span> to navigate the tree until he finds <span class="arithmatex">\(V_{\mathbf{fk}}\)</span> stored at <span class="arithmatex">\(\mathbf{L_{fk}} := \mathbf{{B}_{ab}}\)</span>. </p>
<p>He subsequently starts the Merkle proof by hashing the value <span class="arithmatex">\(\tilde{V}_{\mathbf{fk}}\)</span> stored at the located leaf. Since, this computation amounts to forming a leaf, he uses the leaf-hash function, <span class="arithmatex">\(\mathbf{H}_{\mathbf{leaf}}\)</span>. </p>
<ul>
<li>He then sets <span class="arithmatex">\(\tilde{\mathbf{L}}_{\mathbf{fk}}  :=  \mathbf{H}_{\mathbf{leaf}} \big( V_{\mathbf{fk}} \big) = \mathbf{H}_{\mathbf{leaf}} \big( \mathbf{L_{a}} \| \mathbf{L_{b}} \big)\)</span>.</li>
<li>And further computes  <span class="arithmatex">\(\tilde{ \mathbf{B}}_{\mathbf{fkcd}} = \mathbf{H}_{\mathbf{noleaf}} \big( \tilde{\mathbf{L}}_{\mathbf{fk}} \| \mathbf{S}_{\mathbf{cd}}  \big)\)</span>. </li>
<li>Again, calculates the root,  <span class="arithmatex">\(\tilde{ \mathbf{root}}_{\mathbf{ab..f}} = \mathbf{H}_{\mathbf{noleaf}} \big( \tilde{ \mathbf{B}}_{\mathbf{fkcd}}\| \mathbf{S}_{\mathbf{ef}} \big)\)</span>.</li>
</ul>
<p>But the actual branch <span class="arithmatex">\(\mathbf{{B}_{ab}}\)</span> was constructed with the no-leaf-hash function, 
<span class="arithmatex">\(\mathbf{H}_{\mathbf{noleaf}}\)</span>. That is, </p>
<div class="arithmatex">\[\begin{aligned}
\mathbf{{B}_{ab}} = \mathbf{H}_{\mathbf{noleaf}} (\mathbf{L_{a}} \| \mathbf{L_{b}}) \neq \mathbf{H}_{\mathbf{leaf}} \big(\mathbf{L_{a}} \| \mathbf{L_{b}} \big) = \tilde{\mathbf{L}}_{\mathbf{fk}}.
\end{aligned}\]</div>
<p>The parent branch <span class="arithmatex">\({\mathbf{B}}_{\mathbf{abcd}}\)</span> also, was constructed as, <span class="arithmatex">\({\mathbf{B}}_{\mathbf{abcd}} = \mathbf{H}_{\mathbf{noleaf}} \big( \mathbf{B}_{\mathbf{ab}}\| { \mathbf{S}}_{\mathbf{cd}} \big)\)</span>. 
Since the hash functions used are collision-resistant, 
<span class="arithmatex">\({\mathbf{B}}_{\mathbf{abcd}}\)</span> cannot be equal to 
<span class="arithmatex">\(\mathbf{H}_{\mathbf{noleaf}} \big( \tilde{\mathbf{L}}_{\mathbf{fk}} \| \mathbf{S}_{\mathbf{cd}}  \big)  = \tilde{ \mathbf{B}}_{\mathbf{fkcd}}\)</span>. 
Consequently, <span class="arithmatex">\(\mathbf{root}_{\mathbf{ab..f}}  \neq \tilde{ \mathbf{root}}_{\mathbf{ab..f}}\)</span>.
Therefore, the Merkle Proof fails. </p>
<h3 id="non-binding-key-value-pairs">Non-Binding Key-Value Pairs</h3>
<p>Whenever the verifier needs to check inclusion of the given key-value pair <span class="arithmatex">\((K_{\mathbf{x}}, \text{V}_{\mathbf{x}})\)</span> in a binary SMT identified by the <span class="arithmatex">\(\mathbf{{root}_{a..x}}\)</span>, he first navigates the SMT in order to locate the leaf <span class="arithmatex">\(\mathbf{{L}_{x}}\)</span> storing <span class="arithmatex">\(\text{V}_{\mathbf{x}}\)</span>, and thereafter carries out two computations. </p>
<p>Both computations involve climbing the tree from the located leaf <span class="arithmatex">\(\mathbf{{L}_{x}}\)</span> back to the root, <span class="arithmatex">\(\mathbf{{root}_{a..x}}\)</span>. And the two computations are;</p>
<ol>
<li>Checking <strong>correctness of the key</strong> <span class="arithmatex">\(K_{\mathbf{x}}\)</span>. </li>
</ol>
<p>That is, verifier takes the Remaining Key, <span class="arithmatex">\(\text{RK}_{\mathbf{x}}\)</span>, and reconstructs the key <span class="arithmatex">\(K_{\mathbf{x}}\)</span> by concatenating the key bits used to navigate to <span class="arithmatex">\(\mathbf{{L}_{x}}\)</span> from <span class="arithmatex">\(\mathbf{{root}_{a..x}}\)</span>, in the reverse order.</p>
<p>Suppose the <em>number of levels to root</em> is 3, and the least-significant bits used for navigation are <span class="arithmatex">\(\text{kb}_\mathbf{2}\)</span>, <span class="arithmatex">\(\text{kb}_\mathbf{1}\)</span> and <span class="arithmatex">\(\text{kb}_\mathbf{0}\)</span>.</p>
<p>In order to check key-correctness, verifier the remaining key <span class="arithmatex">\(\text{RK}\)</span> and,</p>
<p>(a)  Concatenates <span class="arithmatex">\(\text{kb}_\mathbf{2}\)</span> and gets <span class="arithmatex">\(\text{ } \text{RK} \|  \text{kb}_\mathbf{2}\)</span>,</p>
<p>(b)  Concatenates <span class="arithmatex">\(\text{kb}_\mathbf{1}\)</span> then gets <span class="arithmatex">\(\text{ } \text{RK} \|  \text{kb}_\mathbf{2} \| \text{kb}_\mathbf{1}\)</span>,</p>
<p>(c)  Concatenates <span class="arithmatex">\(\text{kb}_\mathbf{0}\)</span> and gets <span class="arithmatex">\(\text{ }  \text{RK} \|  \text{kb}_\mathbf{2} \| \text{kb}_\mathbf{1} \| \text{kb}_\mathbf{0}\)</span>.</p>
<p>He then sets <span class="arithmatex">\(\tilde{K}_{\mathbf{x}} := \text{RK} \|  \text{kb}_\mathbf{2} \| \text{kb}_\mathbf{1} \| \text{kb}_\mathbf{0}\)</span>, and checks if <span class="arithmatex">\(\tilde{K}_{\mathbf{x}}\)</span> equals <span class="arithmatex">\(K_{\mathbf{x}}\)</span>. </p>
<ol>
<li><strong>The Merkle proof</strong>: That is, checking whether the value stored at the located leaf <span class="arithmatex">\(\mathbf{{L}_{x}}\)</span> was indeed included in computing the root, <span class="arithmatex">\(\mathbf{{root}_{a..x}}\)</span>. </li>
</ol>
<p>This computation was illustrated several times in the above discussions. Note that the <em>key-correctness</em> and the Merkle proof are simultaneously carried out. </p>
<h4 id="example-3-indistinguishable-leaves">Example 3. (Indistinguishable Leaves)</h4>
<p>Suppose a binary SMT contains a key-value pair <span class="arithmatex">\((K_{\mathbf{d}}, V_\mathbf{{d}})\)</span> at the leaf <span class="arithmatex">\(\mathbf{L_{d}}\)</span>, where <span class="arithmatex">\(K_{\mathbf{d}} = 11100110\)</span>. 
That is, <span class="arithmatex">\(\mathbf{L_{d}} := \mathbf{H_{leaf}}(V_\mathbf{{d}})\)</span>.</p>
<p>Note that, when building binary SMTs, it is permissible to have another key-value pair <span class="arithmatex">\((K_{\mathbf{x}}, V_\mathbf{{x}})\)</span> in the same tree with <span class="arithmatex">\(V_\mathbf{{x}} = V_\mathbf{{d}}\)</span>.</p>
<p>An Attacker can pick the key-value pair <span class="arithmatex">\((K_{\mathbf{x}}, V_\mathbf{{x}})\)</span> such that <span class="arithmatex">\(V_\mathbf{{x}} = V_\mathbf{{d}}\)</span> and <span class="arithmatex">\(K_{\mathbf{x}} = 10100110\)</span>. And, with the above design, it means  <span class="arithmatex">\(\mathbf{L_{x}} = \mathbf{H_{leaf}}(V_\mathbf{{x}}) = \mathbf{H_{leaf}}(V_\mathbf{{d}}) =  \mathbf{L_{d}}\)</span>.</p>
<p>Consider Figure 8 below. And suppose the Attacker provides the following data;</p>
<ul>
<li>The key-value <span class="arithmatex">\((K_{\mathbf{x}}, V_\mathbf{{x}})\)</span>, where 
  <span class="arithmatex">\(K_{\mathbf{x}} = 10100110\)</span> and <span class="arithmatex">\(V_{\mathbf{x}} = V_\mathbf{d}\)</span>.</li>
<li>The root, <span class="arithmatex">\(\mathbf{{root}_{a..x}}\)</span>, the number of <em>levels to root</em> = 3, and the siblings 
<span class="arithmatex">\(\mathbf{{B}_{\mathbf{bc}}}\)</span>, <span class="arithmatex">\(\mathbf{L_{a}}\)</span> and  <span class="arithmatex">\(\mathbf{{S}_{\mathbf{efg}}}\)</span>. </li>
</ul>
<p>The verifier uses the least-significant key bits; <span class="arithmatex">\(\text{kb}_\mathbf{0} = 0\)</span>, 
<span class="arithmatex">\(\text{kb}_\mathbf{1} = 0\)</span> and <span class="arithmatex">\(\text{kb}_\mathbf{2} = 1\)</span>; 
to navigate the tree and locate the leaf <span class="arithmatex">\(\mathbf{L_{x}}\)</span> which is positioned at <span class="arithmatex">\(\mathbf{L_{d}}\)</span>, see Figure 7 below.</p>
<p><img alt="Figure 8: Non-binding Key-Value Pairs" src="../fig7-non-binding-eg0.png" /></p>
<div align="center"><b> Figure 8: Non-binding Key-Value Pairs</b></div>

<p>In order to ensure that <span class="arithmatex">\(\mathbf{L_{x}}\)</span> actually stores the value <span class="arithmatex">\(V_\mathbf{{x}}\)</span>; The verifier first checks key-correctness. He takes the remaining key <span class="arithmatex">\(\text{RK} = 10100\)</span> and, </p>
<p>​(a)    Concatenates <span class="arithmatex">\(\text{kb}_\mathbf{2} = 1\)</span>, and gets <span class="arithmatex">\(\text{ } \text{RK} \| \text{kb}_\mathbf{2} = 10100 \|1\)</span>,</p>
<p>​(b)    Concatenates <span class="arithmatex">\(\text{kb}_\mathbf{1} = 0\)</span>  to get <span class="arithmatex">\(\text{ } \text{RK} \| \text{kb}_\mathbf{2} \|  \text{kb}_\mathbf{1} = 10100 \|1\|0\)</span>,</p>
<p>​(c)    Concatenates <span class="arithmatex">\(\text{kb}_\mathbf{0} = 0\)</span>, yielding <span class="arithmatex">\(\text{ }  \text{RK} \| \text{kb}_\mathbf{2} \|  \text{kb}_\mathbf{1} \| \text{kb}_\mathbf{0} = 10100 \|1\|0\|0\)</span>. </p>
<p>He sets <span class="arithmatex">\(\tilde{K}_{\mathbf{x}} := 10100 \|1\|0\|0 = 10100100\)</span>. 
Since <span class="arithmatex">\(\tilde{K}_{\mathbf{x}}\)</span> equals <span class="arithmatex">\(K_{\mathbf{x}}\)</span>, the verifier concludes that the supplied key is correct.</p>
<p>As the verifier 'climbs' the tree to test key-correctness, he concurrently checks if the value <span class="arithmatex">\(V_\mathbf{{x}}\)</span> is included in the SMT identified by the given root, <span class="arithmatex">\(\mathbf{{root}_{a..x}}\)</span>. That is, he executes the following computations;</p>
<p>​   (a) He computes the hash of <span class="arithmatex">\(V_\mathbf{{x}}\)</span> and sets it as, <span class="arithmatex">\(\tilde{\mathbf{L}}_\mathbf{x}:= \mathbf{H_{leaf}}(V_\mathbf{{x}})\)</span>.</p>
<p>​   (b) Then he uses <span class="arithmatex">\(\mathbf{{B}_{\mathbf{bc}}}\)</span> to compute, <span class="arithmatex">\(\tilde{\mathbf{B}}_{\mathbf{bcd}} = \mathbf{H_{noleaf}}(\mathbf{{B}_{\mathbf{bc}}} \|\tilde{\mathbf{L}}_\mathbf{x})\)</span>.</p>
<p>​   (c) He also uses <span class="arithmatex">\(\mathbf{L_{a}}\)</span> to compute, <span class="arithmatex">\(\tilde{\mathbf{B}}_{\mathbf{abcd}} = \mathbf{H_{noleaf}}(\mathbf{L_{a}} \| \tilde{\mathbf{B}}_{\mathbf{bcd}})\)</span>.</p>
<p>​   (d) He further calculates, <span class="arithmatex">\(\tilde{\mathbf{root}}_{\mathbf{abcd}} = \mathbf{H_{noleaf}}(\tilde{\mathbf{B}}_{\mathbf{abcd}} \| \mathbf{{S}_{\mathbf{efg}}})\)</span>. </p>
<p>Next, the verifier checks if <span class="arithmatex">\(\tilde{\mathbf{root}}_{\mathbf{abcd}}\)</span> equals <span class="arithmatex">\(\mathbf{root}_{\mathbf{abcd}}\)</span>.</p>
<p>Since <span class="arithmatex">\(V_\mathbf{{x}} = V_\mathbf{{d}}\)</span>, it follows that all the corresponding intermediate values to the root are equal;</p>
<ul>
<li><span class="arithmatex">\(\mathbf{L_{d}} = \mathbf{H_{leaf}}(V_\mathbf{{d}}) = \mathbf{H_{leaf}}(V_\mathbf{{x}}) = \tilde{\mathbf{L}}_\mathbf{x}\)</span>, </li>
<li><span class="arithmatex">\(\mathbf{B}_{\mathbf{bcd}} = \mathbf{H_{noleaf}}(\mathbf{{B}_{\mathbf{bc}}} \| \mathbf{L}_\mathbf{d}) = \mathbf{H_{noleaf}}(\mathbf{{B}_{\mathbf{bc}}} \|\tilde{\mathbf{L}}_\mathbf{x}) = \tilde{\mathbf{B}}_{\mathbf{bcd}}\)</span>, </li>
<li><span class="arithmatex">\(\mathbf{B}_{\mathbf{abcd}} = \mathbf{H_{noleaf}}(\mathbf{L_{a}} \| \mathbf{B}_{\mathbf{bcd}} ) = \mathbf{H_{noleaf}}(\mathbf{L_{a}} \| \tilde{\mathbf{B}}_{\mathbf{bcd}} ) = \tilde{\mathbf{B}}_{\mathbf{abcd}}\)</span>,</li>
<li><span class="arithmatex">\(\mathbf{root}_{\mathbf{abcd}} = \mathbf{H_{noleaf}}(\mathbf{B}_{\mathbf{abcd}} \| \mathbf{{S}_{\mathbf{efg}}} )  = \mathbf{H_{noleaf}}(\tilde{\mathbf{B}}_{\mathbf{abcd}} \| \mathbf{{S}_{\mathbf{efg}}} ) = \tilde{\mathbf{root}}_{\mathbf{abcd}}\)</span>.  </li>
</ul>
<p>The verifier therefore concludes that the key-value pair <span class="arithmatex">\((K_{\mathbf{x}}, V_\mathbf{{x}})\)</span> is in the SMT, when it is not.</p>
<p><strong>Why is this attack successful?</strong></p>
<p>Note that equality of values, <span class="arithmatex">\(V_\mathbf{{x}} = V_\mathbf{{d}}\)</span>, associated with two distinct keys, has nothing to do with the efficacy of this attack. In fact, for all practical purposes, it should be permissible for distinct leaves to store any value, irrespective of whether other leaves store an equivalent value or not.</p>
<p>The downfall of our binary SMTs design, thus far, is that it does not give the verifier any equation that relates or ties the keys to their associated values.</p>
<p>In other words, the attack succeeds simply because the key-value pairs (as 'committed' values) are not binding.</p>
<h4 id="solution-to-the-non-binding-key-value-problem">Solution To The Non-Binding Key-Value Problem</h4>
<p>The solution to this problem is straightforward, and it is to build the binary SMTs in such a way that the key-value pairs are binding. </p>
<p>This means, create a relationship between the keys and their associated values, so that the verifier can simply check if this relationship holds true.</p>
<p>In order to ensure that <em>checking such a relationship</em> blends with the usual proof machinery, one has two options. </p>
<p>The naïve solution, which involves the keys, is one option.</p>
<h5 id="the-naive-solution">The Naïve Solution</h5>
<p>The naïve solution is to simpy include keys in the argument of the hash function, when forming leaves.</p>
<p>That is, when building a binary SMT, one includes a key-value pair <span class="arithmatex">\((K_{\mathbf{x}}, V_\mathbf{{x}})\)</span> by setting the leaf <span class="arithmatex">\(\mathbf{L_{x}}\)</span> to be the hash of both the value and the key;</p>
<div class="arithmatex">\[\begin{aligned}
\mathbf{L_{x}} = \mathbf{H_{leaf}}(K_{\mathbf{x}} \| V_\mathbf{{x}} )
\end{aligned}\]</div>
<p><strong>Does this change remedy the non-binding problem?</strong></p>
<p>Suppose <span class="arithmatex">\((K_{\mathbf{x}}, V_\mathbf{{x}})\)</span> and <span class="arithmatex">\((K_{\mathbf{z}}, V_\mathbf{{z}})\)</span> are two key-value pairs such that <span class="arithmatex">\(V_\mathbf{{x}} = V_\mathbf{{z}}\)</span> , while <span class="arithmatex">\(K_\mathbf{{x}}\)</span> and <span class="arithmatex">\(K_\mathbf{{z}}\)</span> differ only in one of the most-significant bits.</p>
<p>Since the hash functions used are collision-resistant, it follows that </p>
<div class="arithmatex">\[\begin{aligned}
\mathbf{L_{x}} = \mathbf{H_{leaf}}(K_{\mathbf{x}} \| V_\mathbf{{x}}) \neq \mathbf{H_{leaf}}(K_{\mathbf{z}} \| V_\mathbf{{z}}) = \mathbf{L_{z}}
\end{aligned}\]</div>
<p>Consequently, although the key-value pairs <span class="arithmatex">\((K_{\mathbf{x}}, V_\mathbf{{x}})\)</span> and <span class="arithmatex">\((K_{\mathbf{z}}, V_\mathbf{{z}})\)</span> might falsely pass the key-correctness check, they will not pass the Merkle proof test. And this is because, collision-resistance also guarantees that the following series of inequalities hold true;</p>
<div class="arithmatex">\[\begin{aligned}
\mathbf{L_{x}} = \mathbf{H_{leaf}}(K_{\mathbf{x}} \| V_\mathbf{{x}}) \neq \mathbf{H_{leaf}}(K_{\mathbf{z}} \| V_\mathbf{{z}}) = \mathbf{L_{z}} \\ 
\\ 
\mathbf{B_{bx}} = \mathbf{H_{noleaf}}(\mathbf{S}_\mathbf{{b}} \| \mathbf{L}_{\mathbf{x}}) \neq \mathbf{H_{noleaf}}(\mathbf{S}'_\mathbf{{b}} \| \mathbf{L}_{\mathbf{z}}) = \mathbf{B_{bz}} \\ 
\\ 
\mathbf{B_{abx}} = \mathbf{H_{noleaf}}(\mathbf{S}_\mathbf{{a}} \| \mathbf{B_{bx}} ) \neq \mathbf{H_{noleaf}}(\mathbf{S}'_\mathbf{{a}} \| \mathbf{B_{bz}}) = \mathbf{B_{abz}}
\end{aligned}\]</div>
<p>where; <span class="arithmatex">\(\mathbf{S}_\mathbf{{b}}\)</span> is a sibling to <span class="arithmatex">\(\mathbf{L}_{\mathbf{x}}\)</span>, and <span class="arithmatex">\(\mathbf{S}_\mathbf{{a}}\)</span> is a sibling to <span class="arithmatex">\(\mathbf{B_{bx}}\)</span>, making <span class="arithmatex">\(\mathbf{B_{bx}}\)</span> and <span class="arithmatex">\(\mathbf{B_{abx}}\)</span> branches traversed while climbing the tree from <span class="arithmatex">\(\mathbf{L_{x}}\)</span> to root; Similarly,  <span class="arithmatex">\(\mathbf{S}'_\mathbf{{b}}\)</span> is a sibling to <span class="arithmatex">\(\mathbf{L}_{\mathbf{z}}\)</span>, while <span class="arithmatex">\(\mathbf{S}'_\mathbf{{a}}\)</span> is a sibling to <span class="arithmatex">\(\mathbf{B_{bx}}\)</span>, also making <span class="arithmatex">\(\mathbf{B_{bz}}\)</span> and <span class="arithmatex">\(\mathbf{B_{abz}}\)</span> branches traversed while climbing the tree from <span class="arithmatex">\(\mathbf{L_{z}}\)</span> to root.</p>
<p>The only chance for the Merkle proof to pass is if the key-value pairs <span class="arithmatex">\((K_{\mathbf{x}}, V_\mathbf{{x}})\)</span> and <span class="arithmatex">\((K_{\mathbf{z}}, V_\mathbf{{z}})\)</span> are distinct and are individually on the same SMT. </p>
<p>The inclusion of keys, in the argument of the hash functions, therefore ensures that leaves <span class="arithmatex">\(\mathbf{L_{x}}\)</span> and <span class="arithmatex">\(\mathbf{L_{z}}\)</span> are distinguishable. And most importantly, that key-value pairs in our SMTs are now binding.</p>
<h5 id="a-better-solution">A Better Solution</h5>
<p>The other solution, which is much more apt than the Naïve option, utilises the remaining keys when forming leaves.</p>
<p>Since <em>levels to root</em> is related to the <em>Remaining Key</em> (<span class="arithmatex">\(\text{RK}\)</span>) notion, a much more apt solution is to rather include the remaining key, <span class="arithmatex">\(\text{RK}_\mathbf{x}\)</span>, as the argument to the hash function, instead of the whole key <span class="arithmatex">\(K_{\mathbf{x}}\)</span>.</p>
<p>That is, for a key-value pair <span class="arithmatex">\((K_{\mathbf{x}}, V_\mathbf{{x}})\)</span>, one sets the leaf <span class="arithmatex">\(\mathbf{L_{x}}\)</span> to be the hash of both the value and the remaining key;</p>
<div class="arithmatex">\[\begin{aligned}
\mathbf{L_{x}} = \mathbf{H_{leaf}}( \text{RK}_\mathbf{x}  \| \text{V}_\mathbf{{x}}).
\end{aligned}\]</div>
<p>With this strategy, the verifier needs the remaining key <span class="arithmatex">\(\text{RK}_\mathbf{{x}}\)</span> , instead of the whole key, in order to carry out a Merkle proof. So he adjusts the Merkle proof by; </p>
<ul>
<li>Firstly, picking the correct hash function <span class="arithmatex">\(\mathbf{H_{leaf}}\)</span> for leaves, </li>
<li>Secondly, concatenating the value <span class="arithmatex">\(V_{\mathbf{x}}\)</span> stored at the leaf <span class="arithmatex">\(L_{\mathbf{x}}\)</span> and the remaining key <span class="arithmatex">\(\text{RK}_\mathbf{{x}}\)</span>, instead of the whole key <span class="arithmatex">\(K_{\mathbf{x}}\)</span>,</li>
<li>Thirdly, hashing the concatenation <span class="arithmatex">\(\mathbf{H_{leaf}}( \text{RK}_\mathbf{x}  \| \text{V}_\mathbf{{x}}) =: \mathbf{L_{x}}\)</span>.</li>
</ul>
<p>This approach not only ensures that key-value pairs in our SMTs are now binding, but also implicitly 'encodes' the levels to root in the leaf.</p>
<p>The strategy of using the <span class="arithmatex">\(\text{RK}_\mathbf{x}\)</span> instead of the key <span class="arithmatex">\(K_{\mathbf{x}}\)</span>, coupled with hashing leaves and branches differently, yields sound verification.</p>
<h4 id="introducing-zero-knowledge">Introducing Zero-Knowledge</h4>
<p>It is often necessary to make sure that a proof-integrity system has the zero-knowledge property. In order to introduce zero-knowledge, instead of storing values as plaintexts in the leaves, one stores hashes of these values.</p>
<p>A leaf therefore is henceforth constructed in two steps;</p>
<ul>
<li>Firstly, for a key-value pair <span class="arithmatex">\((K_{\mathbf{x}}, V_\mathbf{{x}})\)</span>, compute the hash the value <span class="arithmatex">\(V_\mathbf{{x}}\)</span>, </li>
</ul>
<div class="arithmatex">\[\begin{aligned}
  \text{Hashed Value} = \text{HV}_\mathbf{{x}} = \mathbf{H_{noleaf}}(V_\mathbf{{x}})
\end{aligned}\]</div>
<ul>
<li>Secondly, form the leaf containing <span class="arithmatex">\(V_\mathbf{{x}}\)</span>, as follows,</li>
</ul>
<div class="arithmatex">\[\begin{aligned}
  \mathbf{L_{x}} = \mathbf{H_{leaf}}(  \text{RK}_\mathbf{x}  \| \text{HV}_\mathbf{{x}})
\end{aligned}\]</div>
<p>Since it is infeasible to compute the preimage of the hash functions, <span class="arithmatex">\(\mathbf{H_{leaf}}\)</span> and <span class="arithmatex">\(\mathbf{H_{noleaf}}\)</span>, computing the hash of the value <span class="arithmatex">\(V_\mathbf{{x}}\)</span> amounts to 'encrypting'.</p>
<p>The prover therefore achieves zero-knowledge by providing the pair, <span class="arithmatex">\((K_{\mathbf{x}}, \text{HV}_\mathbf{{x}})\)</span>, as the key-value pair instead of the explicit one, <span class="arithmatex">\((K_{\mathbf{x}}, V_\mathbf{{x}})\)</span>.</p>
<p>The verifier, on the other hand, has to adjust the Merkle proof by starting with; </p>
<ul>
<li>Firstly, picking the correct hash function <span class="arithmatex">\(\mathbf{H_{leaf}}\)</span> for leaf nodes,</li>
<li>Secondly, concatenating the hashed-value <span class="arithmatex">\(\text{HV}_\mathbf{{x}}\)</span> and the remaining key <span class="arithmatex">\(\text{RK}_\mathbf{{x}}\)</span>,</li>
<li>Thirdly, hashing the concatenation in order to form the leaf, <span class="arithmatex">\(\mathbf{L_{x}} := \mathbf{H_{leaf}}( \text{RK}_\mathbf{x}  \| \text{HV}_\mathbf{{x}})\)</span>.</li>
</ul>
<h4 id="example-4-zero-knowledge-merkle-proof">Example 4. (Zero-Knowledge Merkle Proof)</h4>
<p>The following example illustrates a Merkle proof when the above strategy is applied.</p>
<p>Consider an SMT where the keys are 8-bit long, and the prover commits to the key-value <span class="arithmatex">\(( K_{\mathbf{c}} , \text{HV}_{\mathbf{c}} )\)</span> with <span class="arithmatex">\(K_{\mathbf{c}} = 10010100\)</span>. See Figure 9 below. </p>
<p><img alt="Figure 9 : ZK Merkle Proof Example" src="../fig8-zk-mkl-prf.png" /></p>
<div align="center"><b> Figure 9 : ZK Merkle Proof Example </b></div>

<p>Since the levels to root is 3, the prover provides; the least-significant key-bits, <span class="arithmatex">\(\text{kb}_0 = 0\)</span>, <span class="arithmatex">\(\text{kb}_1 = 0\)</span>, <span class="arithmatex">\(\text{kb}_2 = 1\)</span>, the stored hashed-value <span class="arithmatex">\(\text{HV}_{\mathbf{c}}\)</span>, the root  <span class="arithmatex">\(\mathbf{{root}_{a..f}}\)</span>, the Remaining Key <span class="arithmatex">\(\mathbf{ \text{RK}_{\mathbf{c}}} = 10010\)</span>, and the siblings <span class="arithmatex">\(\mathbf{{S}_{ab}}\)</span>, <span class="arithmatex">\(\mathbf{{L}_{d}}\)</span> and <span class="arithmatex">\(\mathbf{{S}_{\mathbf{ef}}}\)</span>.</p>
<p>The verifier first uses the least-significant bits of the key <span class="arithmatex">\(K_{\mathbf{c}} = 10010100\)</span> to navigate the SMT from the root, <span class="arithmatex">\(\mathbf{{root}_{a..f}}\)</span>, to the leaf <span class="arithmatex">\(\mathbf{L_c}\)</span>. Then, he executes the following computations;</p>
<ol>
<li>
<p>He computes, <span class="arithmatex">\(\mathbf{L_c} = \mathbf{H_{leaf}}\big( \mathbf{ \text{RK}_{\mathbf{c}}} \| \text{HV}_{\mathbf{c}} \big) = \mathbf{H_{leaf}}( 10010 \| \text{HV}_{\mathbf{c}})\)</span></p>
</li>
<li>
<p>Then, he uses the sibling <span class="arithmatex">\(\mathbf{{S}_{ab}}\)</span> to compute, <span class="arithmatex">\(\tilde{ \mathbf{B}}_{\mathbf{abc}} := \mathbf{H_{noleaf}} \big( \mathbf{{S}_{ab}}\|\mathbf{L}_{\mathbf{c}} \big)\)</span>.</p>
</li>
<li>
<p>Next, he computes, <span class="arithmatex">\(\tilde{ \mathbf{B}}_{\mathbf{abcd}} := \mathbf{H_{noleaf}} \big( \tilde{ \mathbf{B}}_{\mathbf{abc}} \| \mathbf{L}_{\mathbf{d}} \big)\)</span>.</p>
</li>
<li>
<p>Now, verifier uses <span class="arithmatex">\(\tilde{ \mathbf{B}}_{\mathbf{abcd}}\)</span> to compute the <em>supposed</em> root,  <span class="arithmatex">\(\tilde{ \mathbf{root}}_{\mathbf{ab..f}}  := \mathbf{H_{noleaf}} \big( \tilde{ \mathbf{B}}_{\mathbf{abcd}}\| \mathbf{S}_{\mathbf{ef}} \big)\)</span>.</p>
</li>
<li>
<p>Checks if <span class="arithmatex">\(\tilde{ \mathbf{root}}_{\mathbf{ab..f}}\)</span> equals <span class="arithmatex">\({ \mathbf{root}}_{\mathbf{ab..f}}\)</span>.</p>
</li>
</ol>
<p>The verifier accepts that the key-value pair <span class="arithmatex">\(( K_{\mathbf{c}} , V_{\mathbf{c}} )\)</span> is in the SMT only if  <span class="arithmatex">\(\tilde{ \mathbf{root}}_{\mathbf{ab..f}} = { \mathbf{root}}_{\mathbf{ab..f}}\)</span>. And he does this without any clue about the exact value <span class="arithmatex">\(V_{\mathbf{c}}\)</span> which is hidden as <span class="arithmatex">\(\text{HV}_{\mathbf{c}}\)</span>. </p>
<h2 id="basic-operations-storage-actions">Basic Operations (Storage Actions)</h2>
<p>The previous sections have focused on the design of binary SMTs. The problems that cropped up with our initial design have assisted in refining and defining a secure design. While describing the design of binary SMTs, we have extensively utilised the READ or "Get" operation. </p>
<p>Now that the basic design is established, the other operations can be delineated. The operations that the Storage State Machine performs, as per instructions of the Main SM Executor, are called <strong>Storage Actions</strong>. As mentioned above, these are; Create, Read, Update and Delete (CRUD).</p>
<h3 id="the-read-operation">The READ Operation</h3>
<p>First, we illustrate the READ operation, which is in fact a "Get". </p>
<p>The prover can commit to a key-value pair <span class="arithmatex">\((K_{\mathbf{x}}, \text{HV}_{\mathbf{x}})\)</span> where <span class="arithmatex">\(\text{HV}_{\mathbf{x}}\)</span> is the hash of the value <span class="arithmatex">\(V_{\mathbf{x}}\)</span>. That is, he claims that he created a leaf <span class="arithmatex">\(\mathbf{L}_{\mathbf{x}}\)</span> which contains the value <span class="arithmatex">\(V_{\mathbf{x}}\)</span> and it can be located using the key <span class="arithmatex">\(K_{\mathbf{x}}\)</span>.</p>
<p>READ therefore means locating the leaf <span class="arithmatex">\(\mathbf{L}_{\mathbf{x}}\)</span> and verifying that it contains the value <span class="arithmatex">\(V_{\mathbf{x}}\)</span> by using a Merkle proof.</p>
<p>Hence, in addition to <span class="arithmatex">\((K_{\mathbf{x}}, \text{HV}_{\mathbf{x}})\)</span>, prover has to provide the rest of the information needed for completing the Merkle proof. That is, the root, the key-bits <span class="arithmatex">\(\text{kb}_\mathbf{j}\)</span> for locating the leaf <span class="arithmatex">\(\mathbf{L}_{\mathbf{x}}\)</span>, the Remaining Key <span class="arithmatex">\(\text{RK}_\mathbf{x}\)</span>  and all the necessary siblings. </p>
<p><strong>What if the key is not set?</strong></p>
<p>The next example demostrates the READ operation when a key is not set in the tree. That is, it illustrates how to check whether a value is not on a given SMT. </p>
<p>There are two cases that can occur. The given key may lead either to a zero node or to an existing leaf.</p>
<p>If the given <em>key leads to a zero-node</em>, then the verifier needs only prove the existence of the zero-node, and this would sufficiently prove that the key is not set.</p>
<p>But if the given <em>key leads to an existing leaf</em>, the verifier has to prove the leaf exists in the SMT and show that the given key is not the same as the actual key associated with the value at the leaf.  </p>
<h4 id="example-5-when-the-key-is-not-set">Example 5. When The Key Is Not Set</h4>
<p>Suppose the verifier needs to prove that the keys, <span class="arithmatex">\(K_{\mathbf{x}} = 11010101\)</span> and <span class="arithmatex">\(K_{\mathbf{z}} = 10101010\)</span> are not set in the SMT depicted in Figure 10 below. </p>
<h5 id="case-1-when-the-key-leads-to-a-zero-node">Case 1: When the key leads to a zero-node</h5>
<p>The verifier receives the key <span class="arithmatex">\(K_{\mathbf{x}}\)</span>, the remaining key <span class="arithmatex">\(\text{RK}_\mathbf{x} = 1101010\)</span>, the least-significant key-bit <span class="arithmatex">\(\text{kb}_0 = 1\)</span>, and the sibling <span class="arithmatex">\(\mathbf{{S}_{1}} = \mathbf{{B}_{\mathbf{ab}}}\)</span>.</p>
<p>Since the least-significant key-bit of the given key, <span class="arithmatex">\(\text{kb}_0 = 1\)</span>, navigation from the root leads to the right-side, to the zero-node. See the node circled in a green colour, in Figure 9 below.</p>
<p>The task here is to verify that the node is indeed a zero-node.</p>
<p>So the verifier computes the root as follows,  <span class="arithmatex">\(\mathbf{{\tilde{root}}_{ab0}} = \mathbf{H_{noleaf}} (\mathbf{{S}_{1}} \| \mathbf{0} )  = \mathbf{H}( \mathbf{{B}_{\mathbf{ab}}} \| \mathbf{0} )\)</span>. </p>
<p>Note that he concatenates <span class="arithmatex">\(\mathbf{{S}_{1}}\)</span> and <span class="arithmatex">\(\mathbf{0}\)</span> in the given ordering, because <span class="arithmatex">\(\text{kb}_0 = 1\)</span>.</p>
<p>He then checks if  <span class="arithmatex">\(\mathbf{{\tilde{root}}_{ab0}} = \mathbf{{root}_{ab0}}\)</span>. If this is true, then he concludes that the given key is not set.</p>
<p><img alt="Figure 10: Key Not Set Example" src="../fig9-key-not-set-eg.png" /></p>
<div align="center"><b> Figure 10: Key Not Set Example </b></div>

<h5 id="case-2-when-the-key-leads-to-an-existing-leaf">Case 2: When the key leads to an existing leaf</h5>
<p>Consider again the SMT depicted in Figure 10 above, and suppose that the prover claims that the key <span class="arithmatex">\(K_{\mathbf{z}} = 10101010\)</span> is set.</p>
<p>The verifier is given; the key <span class="arithmatex">\(K_{\mathbf{z}} = 10101010\)</span>, the Remaining Key <span class="arithmatex">\(\text{RK}_{\mathbf{z}} = 101010\)</span>, the least-significant key-bit <span class="arithmatex">\(\text{kb}_0 = 0\)</span>, the second least-significant key-bit <span class="arithmatex">\(\text{kb}_{\mathbf{1}} = 1\)</span>, and the siblings  <span class="arithmatex">\(\mathbf{{S}_{1}} = \mathbf{L}_{a}\)</span>  and  <span class="arithmatex">\(\mathbf{{S}_{2}} = \mathbf{0}\)</span>.</p>
<p>When navigating the tree from <span class="arithmatex">\(\mathbf{{root}_{ab0}}\)</span>, using the key-bits <span class="arithmatex">\(\text{kb}_{\mathbf{0}} = 0\)</span> and <span class="arithmatex">\(\text{kb}_{\mathbf{1}} = 1\)</span>, and with reference to Figure 10 above,</p>
<ul>
<li>
<p>the key-bit <span class="arithmatex">\(\text{kb}_{\mathbf{0}}  = 0\)</span> leads to the branch <span class="arithmatex">\(\mathbf{{B}_{\mathbf{ab}}}\)</span>, </p>
</li>
<li>
<p>then from <span class="arithmatex">\(\mathbf{{B}_{\mathbf{ab}}}\)</span>, the key-bit  <span class="arithmatex">\(\text{kb}_{\mathbf{1}} = 1\)</span> leads to the leaf <span class="arithmatex">\(\mathbf{L}_\mathbf{b}\)</span>, which is the leaf circled in brown in Figure 9 above.</p>
</li>
</ul>
<p>Since the key navigates to a leaf, the verifier's task is to prove two things simultaneously;</p>
<ol>
<li>The leaf is in the SMT described in Figure 10, and </li>
<li>The Remaining Key at the leaf <span class="arithmatex">\(\mathbf{L}_\mathbf{b}\)</span> is different from the Remaining Key supplied by the prover.</li>
</ol>
<p>In proving that <span class="arithmatex">\(\mathbf{L}_{\mathbf{b}}\)</span> is indeed in the tree, the verifier does the following;</p>
<p><strong>Checks the root</strong>:</p>
<p>(a) Computes the hash of the hashed-value, <span class="arithmatex">\(\mathbf{ \tilde{L} }_{\mathbf{b}} = \mathbf{H_{leaf}} ( \text{RK}_{\mathbf{b}} \| \text{HV}_{\mathbf{b}} )\)</span>, </p>
<p>(b) Uses the first sibling to compute, <span class="arithmatex">\(\mathbf{{\tilde{B}}_{\mathbf{ab}}} = \mathbf{H_{noleaf}} \big( \mathbf{L}_{\mathbf{a}} \| \mathbf{ \tilde{L}}_{\mathbf{b}} \big)\)</span>, </p>
<p>(c) Then, uses the second sibling to compute the root, <span class="arithmatex">\(\mathbf{\tilde{root}}_{ab0} = \mathbf{H_{noleaf}} \big( \mathbf{{\tilde{B}}_{\mathbf{ab}}} \| \mathbf{0} \big)\)</span>. </p>
<p>(d) Completes the root-check by testing equality, <span class="arithmatex">\(\mathbf{\tilde{root}}_{ab0} = \mathbf{{root}}_{ab0}\)</span>.  </p>
<p>Simultaneously,</p>
<p><strong>Checks the keys</strong>: </p>
<p>The verifier takes the two Remaining Keys <span class="arithmatex">\(\text{RK}_{\mathbf{x}}\)</span> and <span class="arithmatex">\(\text{RK}_{\mathbf{b}}\)</span>, and the key-bits <span class="arithmatex">\(\text{kb}_0\)</span> and <span class="arithmatex">\(\text{kb}_{\mathbf{1}}\)</span>;</p>
<p>(a) Concatenates them as, <span class="arithmatex">\(\tilde{K}_{\mathbf{x}} = \text{RK}_{\mathbf{x}} \| \text{kb}_0 \| \text{kb}_{\mathbf{1}}\)</span> and <span class="arithmatex">\(\tilde{K}_{\mathbf{b}} = \text{RK}_{\mathbf{b}} \| \text{kb}_0 \| \text{kb}_{\mathbf{1}}\)</span>,</p>
<p>(b) Checks <span class="arithmatex">\(\tilde{K}_{\mathbf{x}} = K_{\mathbf{x}}\)</span> and <span class="arithmatex">\(\tilde{K}_{\mathbf{b}} = K_{\mathbf{b}}\)</span>, and</p>
<p>(c) Finally shows the inequality, <span class="arithmatex">\(\tilde{K}_{\mathbf{x}} \neq K_{\mathbf{b}}\)</span>.</p>
<p>This proves that the key <span class="arithmatex">\(K_{\mathbf{x}}\)</span> is not set.</p>
<p><em>Remark</em>: The last check, where the verifier checks inequality of keys, turns out to be very expensive to implement. A much more smarter method is used in the Storage State Machine. </p>
<h3 id="the-update-operation">The UPDATE Operation</h3>
<p>The UPDATE operation does not change the topology of the tree. When carrying out the UPDATE, it is therefore important to retain all labels of nodes.</p>
<p><strong>The UPDATE process</strong> entails the following;</p>
<p>First, the verifier needs to be provided with the following data; The remaining key <span class="arithmatex">\(\text{RK}\)</span>, the least-significant key-bits, the new value, the old value, the old root and the siblings.</p>
<p><strong>Step 1.</strong> <strong><em>Checking a READ</em></strong> of the current value with the old root. That is, checking that the leaf exists in the tree, and it was included in calculating the old root.</p>
<p><strong>Step 2.</strong> <strong><em>Recomputing (updating) all nodes along the path</em></strong>, from the leaf to the root, as well as computing the new root with the newly updated nodes.</p>
<p>The verifier can continue with <strong>Step 2</strong> only if all the checks in <strong>Step 1</strong> pass verification.</p>
<p>For the UPDATE operation, <strong>Step 1</strong> is exactly the same as the READ operation. We therefore focus on illustrating <strong>Step 2</strong>. </p>
<h4 id="example-6-update-step-2">Example 6. UPDATE - Step 2</h4>
<p>Suppose the set key is <span class="arithmatex">\(K_{\mathbf{c}} = 10110100\)</span> corresponding to the old value <span class="arithmatex">\(V_{\mathbf{c}}\)</span>, and the new value is <span class="arithmatex">\(V_\mathbf{new}\)</span>.</p>
<p>The verifier is provided with the following data;</p>
<p>​   (a) the <span class="arithmatex">\(\text{RK}_{\mathbf{c}} = 10110\)</span>, </p>
<p>​   (b) the least-significant key-bit <span class="arithmatex">\(\text{kb}_0 = 0\)</span>, </p>
<p>​   (c) the second least-significant key-bit  <span class="arithmatex">\(\text{kb}_1 = 0\)</span>, </p>
<p>​   (d) the third least-significant key-bit  <span class="arithmatex">\(\text{kb}_2 = 1\)</span>, </p>
<p>​   (e) the old hashed value <span class="arithmatex">\(\text{HV}_{\mathbf{c}}\)</span>,</p>
<p>​   (f) the old root  <span class="arithmatex">\(\mathbf{{root}_{ab..f }}\)</span> , and </p>
<p>​   (g) the siblings  <span class="arithmatex">\(\mathbf{{S}_{1}} = \mathbf{{S}_{\mathbf{ab}}}\)</span>,   <span class="arithmatex">\(\mathbf{{S}_{2}} = \mathbf{{L}_{d}}\)</span>  and  <span class="arithmatex">\(\mathbf{{S}_{3}} = \mathbf{{S}_{\mathbf{ef}}}\)</span>. </p>
<p>Consider the SMT given in Figure 11 below.</p>
<p><img alt="Figure 11: Value UPDATE Example" src="../fig10-val-update-eg.png" /></p>
<div align="center"><b> Figure 11: Value UPDATE Example </b></div>

<p>The required <strong>Step 2</strong> of the UPDATE operation involves, </p>
<p>(a) Computing the hash of the new value <span class="arithmatex">\(V_\mathbf{new}\)</span> as;  <span class="arithmatex">\(\text{HV}_{\mathbf{new}} = \mathbf{H_{noleaf}}(V_\mathbf{new})\)</span>,  </p>
<p>(b) Forming the new leaf by again hashing the hashed value <span class="arithmatex">\(\text{HV}_{\mathbf{new}}\)</span> as;  <span class="arithmatex">\(\mathbf{ \tilde{L} }_{\mathbf{new}} = \mathbf{H_{leaf}}( \text{RK}_{\mathbf{new}} \| \text{HV}_{\mathbf{new}} )\)</span>, </p>
<p>(c) Using the first sibling  <span class="arithmatex">\(\mathbf{{S}_{1}} = \mathbf{{S}_{\mathbf{ab}}}\)</span>  to compute,  <span class="arithmatex">\(\mathbf{{\bar{B}}_{abc}} = \mathbf{H_{noleaf}} \big( \mathbf{{S}_{\mathbf{ab}}} \| \mathbf{ \tilde{L}}_{\mathbf{new}} \big)\)</span>, </p>
<p>(d) Again, using the second sibling <span class="arithmatex">\(\mathbf{{S}_{2}} = \mathbf{{L}_{d}}\)</span> to compute, <span class="arithmatex">\(\mathbf{{\bar{B}}_{\mathbf{abcd}}} = \mathbf{H_{noleaf}} \big( \mathbf{{\bar{B}}_{abc}} \| \mathbf{{L}_{d}} \big)\)</span>, </p>
<p>(e) Then, uses the third sibling <span class="arithmatex">\(\mathbf{{S}_{3}} = \mathbf{{S}_{\mathbf{ef}}}\)</span> to compute the root, <span class="arithmatex">\(\mathbf{{{root}}_{\mathbf{new}}} = \mathbf{H_{noleaf}} \big( \mathbf{{\bar{B}}_{\mathbf{abcd}}} \| \mathbf{{S}_{\mathbf{ef}}}\big)\)</span>.</p>
<p>Note that the key-bits are not changed. Therefore, replacing the following old values in the SMT, 
<span class="arithmatex">\(\text{HV}_\mathbf{c}, \mathbf{{B}_{abc}}, \mathbf{{B}_{abcb}}, \mathbf{{root}_{ab..f } }\)</span>,
with the new ones,
<span class="arithmatex">\(\text{HV}_\mathbf{new}, \mathbf{{\bar{B}}_{abc}}, \mathbf{{\bar{B}}_{abcb}}, \mathbf{{root}_{new } }\)</span>,
respectively, completes the UPDATE operation.</p>
<h3 id="the-create-operation">The CREATE Operation</h3>
<p>The CREATE Operation adds a new leaf <span class="arithmatex">\(\mathbf{L_{\mathbf{new}}}\)</span> to the SMT in order to insert and store a new key-value pair <span class="arithmatex">\(( \mathbf{{K_{new}}} , \mathbf{V_{\mathbf{new}}} )\)</span> at <span class="arithmatex">\(\mathbf{L_{\mathbf{new}}}\)</span>, where the key <span class="arithmatex">\(\mathbf{K_{new}}\)</span> was never used in the SMT and thus is uniquely associated with the leaf <span class="arithmatex">\(\mathbf{L_{new}}\)</span>.</p>
<p>When navigating from the root, the new key <span class="arithmatex">\(\mathbf{K_{new}}\)</span> can lead to either a zero node or an existing leaf. This results in two scenarios.</p>
<h4 id="case-1-new-key-navigates-to-a-zero-node">Case 1: New Key Navigates To A Zero Node</h4>
<p>That is, the first  <span class="arithmatex">\(l\)</span>  least-significant bits of the key <span class="arithmatex">\(\mathbf{K_{new}}\)</span> leads to a zero node, where  <span class="arithmatex">\(l\)</span>  is the <em>levels to root</em> of the zero node.</p>
<p>The first step is to double-check that indeed the node is a zero node. That is, the verifier performs a Merkle proof starting with either <span class="arithmatex">\(\mathbf{H_{noleaf}} ( \mathbf{S_1} \| \mathbf{0} )\)</span> or <span class="arithmatex">\(\mathbf{H_{noleaf}} ( \mathbf{0} \| \mathbf{S_1} )\)</span>, depending on whether the sibling of the zero-node is on the right (the edge corresponding to a key-bit <span class="arithmatex">\(1\)</span>) or on the left (the edge corresponding to a key-bit <span class="arithmatex">\(0\)</span>), respectively.</p>
<p>Once it is established that the new key <span class="arithmatex">\(\mathbf{K_{new}}\)</span> has led to a zero node, the verifier simply changes the zero node to the leaf <span class="arithmatex">\(\mathbf{L_{new}}\)</span> that stores the value <span class="arithmatex">\(\mathbf{V_{new}}\)</span>. </p>
<p>The CREATE operation, in this case, therefore boils down to an UPDATE operation on the zero node. It amounts to;</p>
<ul>
<li>Computing the hash of the new value <span class="arithmatex">\(V_\mathbf{new}\)</span> as,  <span class="arithmatex">\(\text{HV}_{\mathbf{new}} = \mathbf{H_{noleaf}}(V_\mathbf{new})\)</span>, </li>
<li>Then forming the new leaf, <span class="arithmatex">\(\mathbf{L_{new}} = \mathbf{H_{leaf}}( \text{RK}_{\mathbf{new}} \| \text{HV}_{\mathbf{new}})\)</span>,</li>
<li>Recomputing all the nodes along the path climbing from the leaf <span class="arithmatex">\(\mathbf{L_{new}}\)</span> to the root, including computing the new root.</li>
</ul>
<h4 id="example-7-create-operation-at-a-zero-node">Example 7. CREATE Operation at a Zero Node</h4>
<p>Suppose a new leaf with the key-value pair <span class="arithmatex">\(\big(K_{\mathbf{new}}, \text{V}_{\mathbf{new}}\big)\)</span>, where <span class="arithmatex">\(K_{\mathbf{new}} = 11010110\)</span>, needs to be created.</p>
<p>As illustrated in Figure 12 below, the two least-significant key-bits <span class="arithmatex">\(\text{kb}_0 = 0\)</span> and <span class="arithmatex">\(\text{kb}_1 = 1\)</span>, lead to a zero node. That is, navigating from the root;</p>
<p>​   (a) The lsb, <span class="arithmatex">\(\text{kb}_{0} = 0\)</span>  leads to the node <span class="arithmatex">\(\mathbf{{B}_{ab0}}\)</span>, </p>
<p>​   (b) Whilst the second lsb, <span class="arithmatex">\(\text{kb}_{1} = 1\)</span>  leads to a zero node. </p>
<p>At this stage the verifier checks if this is indeed a zero node;</p>
<ol>
<li>First he computes  <span class="arithmatex">\(\mathbf{{\tilde{B}}_{ab0}} = \mathbf{H_{noleaf}} \big( \mathbf{{S}_{\mathbf{ab}}} \| \mathbf{0} \big)\)</span>. </li>
<li>Then he computes  <span class="arithmatex">\(\mathbf{{\tilde{root}}_{ab0c}} = \mathbf{H_{noleaf}} \big( \mathbf{{\tilde{B}}_{ab0}} \| \mathbf{L_{c}} \big)\)</span>. </li>
<li>And, checks if  <span class="arithmatex">\(\mathbf{{\tilde{root}}_{ab0c}}\)</span>  equals  <span class="arithmatex">\(\mathbf{{root}_{ab0c}}\)</span>. </li>
</ol>
<p><img alt="Figure 12: CREATE Operation - Zero Node" src="../fig11-crt-zero-node.png" /></p>
<div align="center"><b> Figure 12: CREATE Operation - Zero Node </b></div>

<p>Once the zero-value is checked, the verifier now creates a non-zero leaf with the key-value pair <span class="arithmatex">\(\big( \mathbf{K_{new}} , \text{HV}_{\mathbf{new}}\big)\)</span>.</p>
<ol>
<li>He computes the hash of <span class="arithmatex">\(\text{V}_{\mathbf{new}}\)</span> as, <span class="arithmatex">\(\text{HV}_{\mathbf{new}} = \mathbf{H_{noleaf}}(V_\mathbf{new})\)</span>, </li>
<li>He then forms the leaf  <span class="arithmatex">\(\mathbf{L_{new}} =  \mathbf{H_{leaf}}(  \text{RK}_{\mathbf{new}} \| \text{HV}_{\mathbf{new}})\)</span>, </li>
<li>Also computes  <span class="arithmatex">\(\mathbf{B_{new}} =  \mathbf{H_{noleaf}} ( \mathbf{{S}_{\mathbf{ab}}} \| \mathbf{L_{new}})\)</span>, </li>
<li>And computes  <span class="arithmatex">\(\mathbf{{root}_{new}} =  \mathbf{H_{noleaf}} ( \mathbf{B_{new}} \| \mathbf{L_{c}} )\)</span>.</li>
</ol>
<p>An UPDATE of these values; the branch <span class="arithmatex">\(\mathbf{B_{ab0}}\)</span> to <span class="arithmatex">\(\mathbf{B_{new}}\)</span> and the old root <span class="arithmatex">\(\mathbf{{root}_{ab0c}}\)</span> to <span class="arithmatex">\(\mathbf{{root}_{new}}\)</span>; completes the CREATE operation.</p>
<p>Note that inserting a new key-value pair at a zero node does not change the topology of the tree.</p>
<h4 id="case-2-new-key-navigates-to-a-non-zero-leaf">Case 2: New Key Navigates To A Non-Zero Leaf</h4>
<p>That is, the first <span class="arithmatex">\(\mathbf{l}\)</span> least-significant bits of the key <span class="arithmatex">\(\mathbf{K_{new}}\)</span> leads to a non-zero leaf <span class="arithmatex">\(\mathbf{L_z}\)</span>, where <span class="arithmatex">\(\mathbf{l}\)</span> is <span class="arithmatex">\(\mathbf{L_z}\)</span>'s number of <em>levels to root</em>. This means, the keys <span class="arithmatex">\(\mathbf{K_{new}}\)</span> and <span class="arithmatex">\(\mathbf{K_{z}}\)</span> share a common string of least-significant key-bits, which is <span class="arithmatex">\(\mathbf{l}\)</span> bits long.</p>
<p>Step 1: <strong>Checking Leaf Inclusion</strong></p>
<p>The first step is to double-check that indeed the value <span class="arithmatex">\(V_\mathbf{z}\)</span> stored at the leaf <span class="arithmatex">\(\mathbf{L_z}\)</span> is indeed included in the root. </p>
<p>That is, the verifier performs a Merkle proof starting with either <span class="arithmatex">\(\mathbf{H_{noleaf}} ( \mathbf{S_1} \| \mathbf{L_z} )\)</span> or <span class="arithmatex">\(\mathbf{H_{noleaf}} ( \mathbf{L_z} \| \mathbf{S_1} )\)</span>, for some sibling <span class="arithmatex">\(\mathbf{S_1}\)</span>. The ordering of the hash arguments depends on whether the sibling of the leaf <span class="arithmatex">\(\mathbf{L_z}\)</span> is on the left (the edge corresponding to a key-bit <span class="arithmatex">\(0\)</span>) or on the right (the edge corresponding to a key-bit <span class="arithmatex">\(1\)</span>), respectively. The check of value-inclusion gets completed by climbing the tree as usual.</p>
<p>Once it is established that the value <span class="arithmatex">\(V_\mathbf{z}\)</span> stored at the leaf <span class="arithmatex">\(\mathbf{L_z}\)</span> is included in the root, the new leaf <span class="arithmatex">\(\mathbf{L_{new}}\)</span> storing the key-value pair can now be created. </p>
<p>Step 2: <strong>Extending The SMT</strong> </p>
<p>Since it is not permissible for two distinct non-zero leaves, <span class="arithmatex">\(\mathbf{L_{new}}\)</span> and <span class="arithmatex">\(\mathbf{L_z}\)</span>, to share a tree-address, a CREATE Operation at <span class="arithmatex">\(\mathbf{L_z}\)</span> results in extending the tree; by adding a new branch <span class="arithmatex">\(\mathbf{B_{ext1}}\)</span> at the tree-address where <span class="arithmatex">\(\mathbf{L_z}\)</span> has been positioned.</p>
<p>As discussed earlier in this document, when building binary SMTs, the aim is to find a tree-address for the new leaf <span class="arithmatex">\(\mathbf{L_{new}}\)</span> which differs from the tree-address of any existing leaf <span class="arithmatex">\(\mathbf{L_z}\)</span>.</p>
<p>So then, for as long as the next corresponding key-bits between <span class="arithmatex">\(\mathbf{K_{new}}\)</span> and <span class="arithmatex">\(\mathbf{K_{z}}\)</span> coincide, a new extension branch needs to be formed.</p>
<p>Here's the general procedure; </p>
<ol>
<li>Start with the next least-significant key-bits, <span class="arithmatex">\(\text{kb}_\mathbf{(l+1)new}\)</span> and <span class="arithmatex">\(\text{kb}_\mathbf{(l+1)z}\)</span> , and check if  <span class="arithmatex">\(\text{kb}_\mathbf{(l+1)new} = \text{kb}_\mathbf{(l+1)z}\)</span> or not.</li>
<li>If they are not the same (i.e., if <span class="arithmatex">\(\text{kb}_\mathbf{(l+1)new} \neq \text{kb}_\mathbf{(l+1)z}\)</span>), then one new extension branch <span class="arithmatex">\(\mathbf{B_{ext1}}\)</span> with <span class="arithmatex">\(\mathbf{L_{new}}\)</span> and <span class="arithmatex">\(\mathbf{L_{z}}\)</span> as its child-nodes, suffices.</li>
<li>But, if <span class="arithmatex">\(\text{kb}_\mathbf{(l+1)new} = \text{kb}_\mathbf{(l+1)z}\)</span> , then another extension branch <span class="arithmatex">\(\mathbf{B_{ext2}}\)</span> needs to be formed. And, the first extension branch <span class="arithmatex">\(\mathbf{B_{ext1}}\)</span> is made a parent-node to both <span class="arithmatex">\(\mathbf{B_{ext2}}\)</span> and a NULL node "<span class="arithmatex">\(\mathbf{0}\)</span>". The key-bit <span class="arithmatex">\(\text{kb}_\mathbf{(l+1)new}\)</span> determines whether the NULL node "<span class="arithmatex">\(\mathbf{0}\)</span>" is on the left or the right.</li>
<li>One then continues with the next least-significant key-bits, <span class="arithmatex">\(\text{kb}_\mathbf{(l+2)new}\)</span> and <span class="arithmatex">\(\text{kb}_\mathbf{(l+2)z}\)</span>, and checks if <span class="arithmatex">\(\text{kb}_\mathbf{(l+2)new} = \text{kb}_\mathbf{(l+2)z}\)</span> or not.</li>
<li>If <span class="arithmatex">\(\text{kb}_\mathbf{(l+2)new} \neq \text{kb}_\mathbf{(l+2)z}\)</span> , then the second extension branch <span class="arithmatex">\(\mathbf{B_{ext2}}\)</span>, with <span class="arithmatex">\(\mathbf{L_{new}}\)</span> and <span class="arithmatex">\(\mathbf{L_{z}}\)</span> as its child-nodes, completes the CREATE operation.</li>
<li>However, if <span class="arithmatex">\(\text{kb}_\mathbf{(l+2)new} = \text{kb}_\mathbf{(l+2)z}\)</span> , then a third extension branch <span class="arithmatex">\(\mathbf{B_{ext3}}\)</span> is formed. And, as before, the second extension branch <span class="arithmatex">\(\mathbf{B_{ext2}}\)</span> is made a parent-node to both <span class="arithmatex">\(\mathbf{B_{ext3}}\)</span> and a NULL node "<span class="arithmatex">\(\mathbf{0}\)</span>". And similarly, the key-bit <span class="arithmatex">\(\text{kb}_\mathbf{(l+2)new}\)</span> determines whether the NULL node "<span class="arithmatex">\(\mathbf{0}\)</span>" is on the left or the right.</li>
<li>This procedure (of extending the tree) continues until, <span class="arithmatex">\(\text{kb}_\mathbf{(l+j)new} \neq \text{kb}_\mathbf{(l+j)z}\)</span> for some <span class="arithmatex">\(j &gt; 2\)</span>. In which case, the <span class="arithmatex">\(\mathbf{(l + j)}\)</span>-th extension branch <span class="arithmatex">\(\mathbf{B_{ext(l + j)}}\)</span>, with the  <span class="arithmatex">\(\mathbf{L_{new}}\)</span> and <span class="arithmatex">\(\mathbf{L_{z}}\)</span> as its child-nodes, completes the CREATE operation.</li>
</ol>
<p>Step 3: <strong>UPDATE of Values</strong></p>
<p>The CREATE Operation is actually only complete once all the values on the navigation path from the new root to the new leaf are updated.</p>
<h5 id="example-8-create-operation-with-a-single-branch-extension">Example 8. CREATE Operation with a Single Branch Extension</h5>
<p>Suppose a leaf needs to be created to store a new key-value pair <span class="arithmatex">\(\big({K_{\mathbf{new}}\ } , V_\mathbf{{new}}\big)\)</span>, where <span class="arithmatex">\(K_{\mathbf{new}} = 11010110\)</span>. </p>
<p>Consider the SMT shown in Figure 13(a) below.</p>
<p>In this example, navigation using the least-significant key-bits, <span class="arithmatex">\(\text{kb}_\mathbf{0} = 0\)</span> and <span class="arithmatex">\(\text{kb}_\mathbf{1} = 1\)</span>, leads to an existing leaf <span class="arithmatex">\(\mathbf{L_{\mathbf{c}}}\)</span>. And the key-value pair <span class="arithmatex">\((V_\mathbf{\mathbf{c}}, \text{HV}_\mathbf{\mathbf{c}})\)</span> stored at <span class="arithmatex">\(\mathbf{L_{\mathbf{c}}}\)</span> has the key <span class="arithmatex">\(K_{\mathbf{c}} = 11010010\)</span>.</p>
<p><strong>Value-Inclusion Check</strong></p>
<p>A value-inclusion check of <span class="arithmatex">\(V_\mathbf{\mathbf{c}}\)</span> is performed before creating any new leaf. Since this amounts to a READ Operation, which has been illustrated in previous examples, we omit how this is done here. </p>
<p>Once <span class="arithmatex">\(V_\mathbf{\mathbf{c}}\)</span> passes the check, the CREATE Operation continues by inserting the new leaf. </p>
<p><strong>New Leaf Insertion</strong></p>
<p>In this example, the new leaf <span class="arithmatex">\(\mathbf{L_{new}}\)</span> cannot be inserted at the key-address <code>01</code> where <span class="arithmatex">\(\mathbf{L_{\mathbf{c}}}\)</span> is positioned. A branch extension <span class="arithmatex">\(\mathbf{{B}_{ext}}\)</span> must therefore be done at the address <code>01</code> with the leaves <span class="arithmatex">\(\mathbf{L_{new}}\)</span> and <span class="arithmatex">\(\mathbf{L_{c}}\)</span> as child-nodes.</p>
<p>Since the third least-significant key-bits of <span class="arithmatex">\(K_{\mathbf{new}}\)</span> and <span class="arithmatex">\(K_{\mathbf{c}}\)</span> are not the same, <span class="arithmatex">\(\text{kb}_\mathbf{2new} = 1\)</span> and <span class="arithmatex">\(\text{kb}_\mathbf{2c} = 0\)</span>, the addresses <code>110</code> and <code>010</code> of the leaves <span class="arithmatex">\(\mathbf{L_{new}}\)</span> and <span class="arithmatex">\(\mathbf{L_{c}}\)</span>, respectively, are distinct.</p>
<p>Therefore, no further extension is necessary. And the CREATE Operation is complete by updating all the values on the navigation path.</p>
<p><img alt="Figure 13(a): CREATE Operation - Non-zero Leaf Node" src="../fig12a-crt-nzleaf-1ext.png" /></p>
<div align="center"><b> Figure 13(a): CREATE Operation - Non-zero Leaf Node </b></div>

<p>The next process, after forming the branch extension, is to UPDATE all the nodes along the path from the root to the new leaf <span class="arithmatex">\(\mathbf{L_{new}}\)</span>. The verifier follows the steps of the UPDATE operation to accomplish this. </p>
<p><strong>UPDATE of SMT Values</strong> </p>
<p>The verifier computes the following,</p>
<ol>
<li>The hashed value, <span class="arithmatex">\(\text{HV}_{\mathbf{new}} = \mathbf{H_{noleaf}}(V_\mathbf{new})\)</span>, </li>
<li>The new leaf,  <span class="arithmatex">\(\mathbf{L_{new}} = \mathbf{H_{leaf}} ( \text{RK}_{\mathbf{new}} \| \text{HV}_{\mathbf{new}})\)</span>, </li>
<li>Then,  <span class="arithmatex">\(\mathbf{B_{ext}} = \mathbf{H_{noleaf}} ( \mathbf{L_{c}} \| \mathbf{L_{new}})\)</span>, </li>
<li>Again,  <span class="arithmatex">\(\mathbf{B_{new}} = \mathbf{H_{noleaf}}( \mathbf{S_{ab}} \| \mathbf{B_{ext}} )\)</span>, </li>
<li>And finally computes,  <span class="arithmatex">\(\mathbf{{root}_{new}} = \mathbf{H_{noleaf}}( \mathbf{B_{new}} \| \mathbf{L_{d}} )\)</span>.</li>
</ol>
<p>This illustrates how the CREATE Operation is performed at a non-zero leaf, when only one branch extension is required.</p>
<h5 id="example-9-create-operation-with-multiple-branch-extensions">Example 9. CREATE Operation with <strong>Multiple Branch Extensions</strong></h5>
<p>This example provides an illustration of the CREATE Operation at a non-zero leaf, where more than one branch extensions are required.</p>
<p>Suppose a leaf must be created to store a new key-value pair <span class="arithmatex">\(\big(K_{\mathbf{new}}, V_\mathbf{new}\big)\)</span>, where <span class="arithmatex">\(K_{\mathbf{new}} = 11010110\)</span>.</p>
<p>Consider the SMT shown in Figure 13(b) below.</p>
<p>Navigating the tree by using the least-significant key-bits, <span class="arithmatex">\(\text{kb}_\mathbf{0} = 0\)</span> and <span class="arithmatex">\(\text{kb}_\mathbf{1} = 1\)</span>, leads to an existing leaf <span class="arithmatex">\(\mathbf{L_{\mathbf{c}}}\)</span>. In this example, suppose the key-value pair <span class="arithmatex">\((K_{\mathbf{c}} , \text{HV}_\mathbf{\mathbf{c}})\)</span> stored at <span class="arithmatex">\(\mathbf{L_{\mathbf{c}}}\)</span> has the key <span class="arithmatex">\(K_{\mathbf{c}} = 11100110\)</span>.</p>
<p><strong>Value-Inclusion Check</strong></p>
<p>Before creating the new leaf, it is important to first check if <span class="arithmatex">\(V_\mathbf{\mathbf{c}}\)</span> is indeed included in the root, <span class="arithmatex">\(\mathbf{root}_\mathbf{abcd}\)</span>. Since this amounts to performing a READ Operation, which has been illustrated in previous examples, we omit here how this is done. </p>
<p>Once <span class="arithmatex">\(V_\mathbf{\mathbf{c}}\)</span> passes the value-inclusion check, the CREATE Operation proceeds with inserting the new leaf. </p>
<p><strong>New Leaf Insertion</strong></p>
<p>Note that the first and second least-significant key-bits for both <span class="arithmatex">\(K_\mathbf{new}\)</span> and <span class="arithmatex">\(K_\mathbf{c}\)</span> are the same. 
That is, <span class="arithmatex">\(\text{kb}_\mathbf{0new} = 0 = \text{kb}_\mathbf{0c}\)</span> and <span class="arithmatex">\(\text{kb}_\mathbf{1new} = 1 = \text{kb}_\mathbf{1c}\)</span>.</p>
<p>As a result, the new leaf <span class="arithmatex">\(\mathbf{L_{new}}\)</span> cannot be inserted at the key-address <code>01</code>, where <span class="arithmatex">\(\mathbf{L_{\mathbf{c}}}\)</span> is positioned. An extension branch <span class="arithmatex">\(\mathbf{{B}_{ext1}}\)</span> is formed at the tree-address <code>01</code>. </p>
<p>But, can the leaves <span class="arithmatex">\(\mathbf{L_{new}}\)</span> and <span class="arithmatex">\(\mathbf{L_{c}}\)</span> be child-nodes to <span class="arithmatex">\(\mathbf{{B}_{ext1}}\)</span>?</p>
<p>Since the third least-significant key-bits of <span class="arithmatex">\(K_\mathbf{new}\)</span> and <span class="arithmatex">\(K_\mathbf{c}\)</span> are the same; that is, <span class="arithmatex">\(\text{kb}_\mathbf{2new} = 1 = \text{kb}_\mathbf{2c}\)</span>; leaves <span class="arithmatex">\(\mathbf{L_{new}}\)</span> and <span class="arithmatex">\(\mathbf{L_{c}}\)</span> cannot be child-nodes to <span class="arithmatex">\(\mathbf{{B}_{ext1}}\)</span>.</p>
<p>Another extension branch <span class="arithmatex">\(\mathbf{{B}_{ext2}}\)</span> is formed at the tree-address <code>011</code>.</p>
<p>Again, since the fourth least-significant key-bits of <span class="arithmatex">\(K_\mathbf{new}\)</span> and <span class="arithmatex">\(K_\mathbf{c}\)</span> are the same;  <span class="arithmatex">\(\text{kb}_\mathbf{3new} = 0 = \text{kb}_\mathbf{3c}\)</span> ; the leaves <span class="arithmatex">\(\mathbf{L_{new}}\)</span> and <span class="arithmatex">\(\mathbf{L_{c}}\)</span> cannot be child-nodes to <span class="arithmatex">\(\mathbf{{B}_{ext2}}\)</span>.</p>
<p>A third extension branch <span class="arithmatex">\(\mathbf{{B}_{ext3}}\)</span> is needed at the tree-address <code>0110</code>.</p>
<p>In this case, the fifth least-significant key-bits of <span class="arithmatex">\(K_\mathbf{new}\)</span> and <span class="arithmatex">\(K_\mathbf{c}\)</span> are different; i.e.,  <span class="arithmatex">\(\text{kb}_\mathbf{4new} = 1\)</span> and <span class="arithmatex">\(\text{kb}_\mathbf{4c} = 0\)</span>. </p>
<p>The leaves <span class="arithmatex">\(\mathbf{L_{new}}\)</span> and <span class="arithmatex">\(\mathbf{L_{c}}\)</span> are now made child-nodes of the extension branch <span class="arithmatex">\(\mathbf{{B}_{ext3}}\)</span>. See Figure 13(b) below.</p>
<p><img alt="Figure 13(b): CREATE Operation - Three Branch Extensions" src="../fig12b-crt-nzleaf-3xt.png" /></p>
<div align="center"><b> Figure 13(b): CREATE Operation - Three Branch Extensions </b></div>

<p>Once unique addresses for the key-value pairs <span class="arithmatex">\(\big( K_{\mathbf{c}} , V_\mathbf{c} \big)\)</span> and <span class="arithmatex">\(\big( K_\mathbf{{new}} , V_{\mathbf{new}}\big)\)</span>  are reached, and the leaf <span class="arithmatex">\(\mathbf{L_{new}}\)</span> is inserted, all the nodes along the navigation path from the new leaf <span class="arithmatex">\(\mathbf{L_{new}}\)</span> to the root are updated as follows. </p>
<p>The verifier computes,</p>
<ol>
<li>The hash of the new value, <span class="arithmatex">\(\text{HV}_\mathbf{new} = \mathbf{H_{noleaf}}(V_\mathbf{new})\)</span>,</li>
<li>The new leaf,  <span class="arithmatex">\(\mathbf{L_{new}} = \mathbf{H_{leaf}} ( \text{RK}_{\mathbf{new}} \| \text{HV}_{\mathbf{new}})\)</span>, </li>
<li>Then,  <span class="arithmatex">\(\mathbf{B_{ext3}} = \mathbf{H_{noleaf}}( \mathbf{L_{c}} \| \mathbf{L_{new}})\)</span>, </li>
<li>Followed by <span class="arithmatex">\(\mathbf{B_{ext2}} = \mathbf{H_{noleaf}}( \mathbf{B_{ext3}}  \| \mathbf{0} )\)</span>,</li>
<li>And,  <span class="arithmatex">\(\mathbf{B_{ext1}} = \mathbf{H_{noleaf}}( \mathbf{0} \| \mathbf{B_{ext2}} )\)</span>,</li>
<li>Again,  <span class="arithmatex">\(\mathbf{B_{new}} = \mathbf{H_{noleaf}}( \mathbf{S_{ab}} \| \mathbf{B_{ext2}} )\)</span>, </li>
<li>And finally computes,  <span class="arithmatex">\(\mathbf{{root}_{new}} = \mathbf{H_{noleaf}}( \mathbf{B_{new}} \| \mathbf{L_{d}} )\)</span>.</li>
</ol>
<p>This completes the CREATE operation at an existing leaf where several branch extensions are needed. </p>
<p>The CREATE operation at a non-leaf node clearly changes the topology of the tree.</p>
<h3 id="the-deleteremove-operation">The DELETE/REMOVE Operation</h3>
<p>The DELETE Operation refers to a removal of a certain key-value pair from a binary SMT. It is in fact the reverse of the CREATE Operation.</p>
<p>There are two types of scenarios that can occur when executing a DELETE Operation.</p>
<p>There is a scenario where a DELETE Operation is equivalent to an UPDATE Operation of a non-zero leaf to a NULL leaf. In this case the topology of the SMT does not change. This occurs when the leaf being deleted has a non-zero sibling-node.</p>
<p>On the other hand, a DELETE Operation can be tantamount to the reverse of a CREATE Operation where extension branches are removed from the tree. The topology of the SMT can drastically change. This scenario occurs when the leaf being removed has a zero sibling-node.</p>
<p>A DELETE Operation involves two main steps;</p>
<p><strong><em>Step 1</em></strong>: A READ of the value to be deleted is executed. That is; </p>
<p>​   (a) Navigating to the value, </p>
<p>​   (b) Checking if the value is included in the root, and </p>
<p>​   (c) Checking if the given key (reconstructed from the given Remaining Key and the least-significant key-bits) matches the key at the leaf (reconstructed from the Remaining Key found at the leaf and the given key-bits).</p>
<p><strong><em>Step 2</em></strong>: This step depends on whether the sibling of the <em>leaf to be deleted</em> is zero or not; </p>
<p>​   (a) If the <strong>sibling is not a zero node</strong>, an UPDATE to a zero is performed.</p>
<p>​   (b) If the <strong>sibling is a zero-node</strong>, an UPDATE to a zero is performed and the parent-node is turned into a NULL node with no child-nodes.</p>
<h4 id="case-1-delete-operation-leaves-with-non-zero-siblings">Case 1: DELETE Operation - Leaves With Non-Zero Siblings</h4>
<p>Consider a DELETE of a key-value pair <span class="arithmatex">\(\big(K_{\mathbf{b}} , V_\mathbf{b} \big)\)</span> where its leaf <span class="arithmatex">\(\mathbf{L_b}\)</span> has a non-zero node sibling.</p>
<p>Suppose the data provided includes; the Remaining Key <span class="arithmatex">\(\tilde{\text{RK}}_{\mathbf{b}}\)</span>, the least-significant key-bits <span class="arithmatex">\(\text{kb}_0 = 0\)</span> and <span class="arithmatex">\(\text{kb}_1 = 1\)</span>, the root <span class="arithmatex">\(\mathbf{{root}_{abc}}\)</span>, and the sibling <span class="arithmatex">\(\mathbf{L_a}\)</span> which is not a zero node and the leaf <span class="arithmatex">\(\mathbf{L_c}\)</span>.</p>
<p>With reference to Figure 14(a) below, navigation leads to the leaf <span class="arithmatex">\(\mathbf{L_b}\)</span>.</p>
<p>Next, perform a Merkle proof to check if the hashed value <span class="arithmatex">\(\text{HV}_\mathbf{b}\)</span> at <span class="arithmatex">\(\mathbf{L_b}\)</span> is included in the given root;</p>
<ul>
<li>Compute <span class="arithmatex">\(\tilde{\mathbf{L}}_\mathbf{b} = \mathbf{H_{leaf}} ( \text{RK}_{\mathbf{b}} \| \text{HV}_\mathbf{b} )\)</span> </li>
<li>Then <span class="arithmatex">\(\tilde{\mathbf{B}}_\mathbf{ab} = \mathbf{H_{noleaf}} ( \mathbf{L_a} \| \tilde{\mathbf{L}}_\mathbf{b})\)</span></li>
<li>And,  <span class="arithmatex">\(\tilde{\mathbf{root}}_\mathbf{abc} = \mathbf{H_{noleaf}} ( \tilde{\mathbf{B}}_\mathbf{ab}  \| \mathbf{L_c} )\)</span></li>
<li>Check if <span class="arithmatex">\(\tilde{\mathbf{root}}_\mathbf{abc}\)</span> equals <span class="arithmatex">\(\mathbf{{root}_{abc}}\)</span>.</li>
</ul>
<p>Simultaneously, check if <span class="arithmatex">\(\tilde{K}_{\mathbf{b}}\)</span> equals <span class="arithmatex">\(\text{K}_{\mathbf{b}}\)</span>, where <span class="arithmatex">\(\tilde{K}_{\mathbf{b}} =  \tilde{\text{RK}}_{\mathbf{b}} \| \text{kb}_1 \| \text{kb}_0\)</span>  and  <span class="arithmatex">\(\text{K}_{\mathbf{b}} =   \text{RK}_{\mathbf{b}} \| \text{kb}_1 \| \text{kb}_0\)</span>  are keys reconstructed while climbing the tree.</p>
<p>Since the sibling <span class="arithmatex">\(\mathbf{L_a}\)</span> is not a zero node, the hashed value <span class="arithmatex">\(\text{HV}_\mathbf{b}\)</span> found at the leaf <span class="arithmatex">\(\mathbf{L_b}\)</span> is updated to a zero. And the values along the navigation path are also updated accordingly. That is,</p>
<ul>
<li>The leaf <span class="arithmatex">\(\mathbf{L_b}\)</span> is set to "<span class="arithmatex">\(\mathbf{0}\)</span>", a zero node.</li>
<li>The parent-node is now, <span class="arithmatex">\(\mathbf{B_{a0}} = \mathbf{H_{noleaf}} ( \mathbf{L_a} \| \mathbf{0} )\)</span>.</li>
<li>And, the new root, <span class="arithmatex">\(\mathbf{{root}_{abc}} =   \mathbf{H_{noleaf}}(\mathbf{B_{a0}} \| \mathbf{L_a})\)</span>. </li>
</ul>
<p>See the above DELETE Operation illustrated in Figure 13(a) below, and notice how the SMT maintains its original shape. </p>
<p><img alt="Figure 14(a): DELETE Operation - Non-Zero Sibling" src="../fig13a-dlt-nz-sib.png" /></p>
<div align="center"><b> Figure 14(a): DELETE Operation - Non-Zero Sibling </b></div>

<h4 id="case-2-delete-operation-leaves-with-zero-siblings">Case 2: DELETE Operation - Leaves With Zero Siblings</h4>
<p>Consider deleting a key-value pair <span class="arithmatex">\(\big(K_{\mathbf{c}} , V_\mathbf{c} \big)\)</span> where its leaf <span class="arithmatex">\(\mathbf{L_c}\)</span> has a zero-node sibling.</p>
<p>As in Case 1 above, suppose the data provided includes; the Remaining Key <span class="arithmatex">\(\tilde{\text{RK}}_{\mathbf{c}}\)</span>, the least-significant key-bits <span class="arithmatex">\(\text{kb}_0 = 0\)</span>, <span class="arithmatex">\(\text{kb}_1 = 1\)</span> and <span class="arithmatex">\(\text{kb}_2 = 1\)</span>, the root <span class="arithmatex">\(\mathbf{{root}_{a0cd}}\)</span>, and the sibling "<span class="arithmatex">\(\mathbf{0}\)</span>" which is a zero node, and the leaves <span class="arithmatex">\(\mathbf{L_a}\)</span> and <span class="arithmatex">\(\mathbf{L_d}\)</span>.</p>
<p>With reference to Figure 14(b) below, navigation leads to the leaf <span class="arithmatex">\(\mathbf{L_c}\)</span>.</p>
<p>The READ step in this case is similar to what is seen in Case 1. </p>
<p>The UPDATE step depends on the sibling of <span class="arithmatex">\(\mathbf{L_c}\)</span>. Since the sibling is "<span class="arithmatex">\(\mathbf{0}\)</span>", an UPDATE of <span class="arithmatex">\(\mathbf{L_c}\)</span> to zero results in the branch <span class="arithmatex">\(\mathbf{B_{0c}}\)</span> having two zero nodes as child-nodes. Since <span class="arithmatex">\(\mathbf{H_{noleaf}} ( \mathbf{0} \| \mathbf{0}) = 0\)</span> , it is therefore expedient to turn the branch <span class="arithmatex">\(\mathbf{B_{0c}}\)</span> into a zero node with no child-nodes. </p>
<p>That is, the UPDATE step of this DELETE Operation concludes as follows;</p>
<ul>
<li>The original branch <span class="arithmatex">\(\mathbf{B_{0c}}\)</span> is now "<span class="arithmatex">\(\mathbf{0}\)</span>", a zero node.</li>
<li>The parent-node is now, <span class="arithmatex">\(\mathbf{B_{a0}} = \mathbf{H_{noleaf}} ( \mathbf{L_a} \| \mathbf{0}  )\)</span>.</li>
<li>And, the new root, <span class="arithmatex">\(\mathbf{{root}_{a0d}} =   \mathbf{H_{noleaf}}(\mathbf{B_{a0}} \| \mathbf{L_d})\)</span>. </li>
</ul>
<p>Notice that, in this example, the DELETE Operation alters the topology of the SMT, as seen in Figure 13(b) below.</p>
<p><img alt="Figure 14(b): DELETE Operation - Zero Sibling" src="../fig13b-dlt-z-sib.png" /></p>
<div align="center"><b> Figure 14(b): DELETE Operation - Zero Sibling </b></div>

<h3 id="concluding-basic-operations">Concluding Basic Operations</h3>
<p>The operations discussed in this section are in fact the very actions the Main State Machine will instruct the Storage State Machine to perform.</p>
<p>The 'prover' and the 'verifier', as used in the above explanations, can loosely be interpreted as the Executor of the Storage State Machine and the Storage SM's PIL code, respectively. The zero-knowledge Assembly (zkASM) of the Storage SM plays the facilitator's role. The zkASM is the interpreter between the Storage SM and the Main State Machine, also between the Storage SM and the POSEIDON State Machine. </p>
<p>The two hash functions used in building the Storage binary SMTs, are special versions of the POSEIDON family of hash functions.</p>
<p>What's left is specifying parameters such as the actual key-length used in the Storage State Machine, how keys and paths are created, as well as cryptographic primitives utilised like the exact POSEIDON hash functions.</p>
<h2 id="zkprover-storage-parameters">zkProver Storage Parameters</h2>
<p>In the Storage SM, the keys and values are strings of 256 bits.</p>
<p>Keys will henceforth be represented as 256-bit unsigned integers, which are quadruples of 64-bit field elements; e.g., <span class="arithmatex">\(\text{Key}_{\mathbf{0123}} = \big( \text{Key}_{\mathbf{0}} , \text{Key}_{\mathbf{1}} , \text{Key}_{\mathbf{2}} , \text{Key}_{\mathbf{3}} \big)\)</span>, where each <span class="arithmatex">\(\text{Key}_{\mathbf{i}} \in \mathbb{F}_p\)</span>, where  <span class="arithmatex">\(p = 2^{64} - 2^{32} + 1\)</span>. </p>
<p>Although hashed-values are also 256-bit long and are used in quadruple form, 'committed' values are 256-bit long and are often expressed as octets. It is mainly due to the POSEIDON SM convention, where 256-bit committed values are input as, <span class="arithmatex">\(\text{V}_{\mathbf{01..7}} = \big( \text{V}_{\mathbf{0}} , \text{V}_{\mathbf{1}} , \text{V}_{\mathbf{2}} , \dots , \text{V}_{\mathbf{7}} \big)\)</span>, and each 32-bit <span class="arithmatex">\(V_{\mathbf{j}}\)</span> chunk of bits.</p>
<p>In fact, almost every other 256-bit value in the Storage is expressed in the form of a quadruple of 64-bit field elements.</p>
<h3 id="creating-keys-and-paths">Creating Keys And Paths</h3>
<h4 id="how-keys-are-created">How Keys Are Created</h4>
<p>In the key-value pair SMT context of our storage design, a key uniquely identifies a leaf. And it is because, although values can change, keys do not. </p>
<p>Keys must consequently be generated deterministically, and in such a way that there are no collisions. That is, there must be a one-to-correspondence between keys and leaves.</p>
<p>A collision-resistant hash function is therefore the best tool for generating keys. And the most convenient way to generate keys is by hashing some specific information so that the resultant hash uniquely identifies the leaf. The <em>specific Information</em> used for generating keys is the <em>Ethereum Address</em> and some constant. The <span class="arithmatex">\(\text{POSEIDON}\)</span> Hash is again used for this purpose.</p>
<h4 id="constructing-navigation-paths">Constructing Navigation Paths</h4>
<p>A path refers to the edges traversed from the root to a leaf. Since the SMTs are binary, all edges can be thought of, as labelled with either a bit "0" or "1"; Edges to the left labelled with a bit "0", while edges to the right are labelled with a bit "1".</p>
<p>Paths are therefore strings of bits, and are derived from keys in a very specific way.</p>
<p>First of all, every key can be thought of as a quadruple, <span class="arithmatex">\(\text{Key}_{\mathbf{0123}} = \big( \text{Key}_{\mathbf{0}} , \text{Key}_{\mathbf{1}} , \text{Key}_{\mathbf{2}} , \text{Key}_{\mathbf{3}} \big) \in \mathbb{F}_{p}^4\)</span>. Denote each key part <span class="arithmatex">\(\text{Key}_{\mathbf{i}}\)</span> bit-wise as, </p>
<div class="arithmatex">\[\begin{aligned}
\text{Key}_{\mathbf{0}} = k_{\mathbf{0,63}\ } k_{\mathbf{0,62}\ } \dots k_{\mathbf{0,2}\ } k_{\mathbf{0,1}\ } k_{\mathbf{0,0} },\ \ \text{Key}_{\mathbf{1}} = k_{\mathbf{1,63}\ } k_{\mathbf{1,62}\ } \dots k_{\mathbf{1,2}\ } k_{\mathbf{1,1}\ } k_{\mathbf{1,0} }, \\\text{Key}_{\mathbf{2}} = k_{\mathbf{2,63}\ } k_{\mathbf{2,62}\ } \dots k_{\mathbf{2,2}\ } k_{\mathbf{2,1}\ } k_{\mathbf{2,0} },\ \ \text{Key}_{\mathbf{3}} = k_{\mathbf{3,63}\ } k_{\mathbf{3,62}\ } \dots k_{\mathbf{3,2}\ } k_{\mathbf{3,1}\ } k_{\mathbf{3,0} },
\end{aligned}\]</div>
<p>where the most-significant bit <span class="arithmatex">\(\text{MSB}(\text{Key}_{\mathbf{i}}) = k_{\mathbf{i,63}\ }\)</span> and the least-significant bit <span class="arithmatex">\(\text{LSB}(\text{Key}_{\mathbf{i}}) = k_{\mathbf{i,0}}\)</span>, for each  <span class="arithmatex">\(\mathbf{i} \in \{ \mathbf{0}, \mathbf{1}, \mathbf{2}, \mathbf{3} \}\)</span>.</p>
<p>The <strong>Navigation Path</strong> to the leaf corresponding to the key <span class="arithmatex">\(\text{Key}_{\mathbf{0123}}\)</span> is defined as the following string of shuffled key-bits;</p>
<div class="arithmatex">\[\begin{aligned}
k_{\mathbf{0,0}\ } k_{\mathbf{1,0}\ } k_{\mathbf{2,0}\ } k_{\mathbf{3,0}\ } k_{\mathbf{0,1}\ } k_{\mathbf{1,1}\ } k_{\mathbf{2,1}\ } k_{\mathbf{3,1}\ } k_{\mathbf{0,2}\ } k_{\mathbf{1,2}\ } k_{\mathbf{2,2}\ } k_{\mathbf{3,2}\ }\\
  \dots k_{\mathbf{0,62}\ }  k_{\mathbf{1,62}\ } k_{\mathbf{2,62}\ }  k_{\mathbf{3,62}\ }  k_{\mathbf{0,63}\ } k_{\mathbf{1,63}\ } k_{\mathbf{2,63}\ } k_{\mathbf{3,63} }.
\end{aligned}\]</div>
<p>That is, the Navigation Path to the leaf corresponding to <span class="arithmatex">\(\text{Key}_{\mathbf{0123}}\)</span> is the string of bits composed of;</p>
<ul>
<li>The least-significant bits of the four key parts, <span class="arithmatex">\(\text{Key}_{\mathbf{0}} , \text{Key}_{\mathbf{1}} , \text{Key}_{\mathbf{2}} , \text{Key}_{\mathbf{3}}\)</span>, appearing in the order of the key parts as: <span class="arithmatex">\(k_{\mathbf{0,0}\ } k_{\mathbf{1,0}\ } k_{\mathbf{2,0}\ } k_{\mathbf{3,0}}\)</span>.</li>
<li>Followed by the second least-significant bits of the four key parts, <span class="arithmatex">\(\text{Key}_{\mathbf{0}} , \text{Key}_{\mathbf{1}} , \text{Key}_{\mathbf{2}} , \text{Key}_{\mathbf{3}}\)</span>, appearing in the order of the key parts as: <span class="arithmatex">\(k_{\mathbf{0,1}\ } k_{\mathbf{1,1}\ } k_{\mathbf{2,1}\ } k_{\mathbf{3,1}}\)</span>. </li>
<li>Then the third least-significant bits of the four key parts, <span class="arithmatex">\(\text{Key}_{\mathbf{0}} , \text{Key}_{\mathbf{1}} , \text{Key}_{\mathbf{2}} , \text{Key}_{\mathbf{3}}\)</span>, appearing in the order of the key parts as: <span class="arithmatex">\(k_{\mathbf{0,2}\ } k_{\mathbf{1,2}\ } k_{\mathbf{2,2}\ } k_{\mathbf{3,2}}\)</span>.</li>
<li>Up until the most-significant bits of the four key parts, <span class="arithmatex">\(\text{Key}_{\mathbf{0}} , \text{Key}_{\mathbf{1}} , \text{Key}_{\mathbf{2}} , \text{Key}_{\mathbf{3}}\)</span>, appearing in the order of the key parts as: <span class="arithmatex">\(k_{\mathbf{0,63}\ } k_{\mathbf{1,63}\ } k_{\mathbf{2,63}\ } k_{\mathbf{3,63} }\)</span>.</li>
</ul>
<p><img alt="Figure 15 : Navigation Path Derivation" src="../fig14-path-frm-key.png" /></p>
<div align="center"><b> Figure 15 : Navigation Path Derivation </b></div>

<p>Note that, this construction ensures that in every quadruplet of consecutive path-bits there is a one-to-one correspondence between the bits and the four parts of the key, <span class="arithmatex">\(\text{Key}_{\mathbf{0}} , \text{Key}_{\mathbf{1}} , \text{Key}_{\mathbf{2}} , \text{Key}_{\mathbf{3}}\)</span>. </p>
<h4 id="reconstructing-the-key-from-path-bits">Reconstructing The Key From Path-Bits</h4>
<p>When executing a basic operation such as an UPDATE of a value at a leaf, one has to reconstruct the key from the remaining key found at the leaf and the path-bits spent in navigating to the leaf.</p>
<p>Denote the remaining key as a quadruple, 
<span class="arithmatex">\(\text{RKey}_{\mathbf{0123}} = \big( \text{RKey}_{\mathbf{0}} , \text{RKey}_{\mathbf{1}} , \text{RKey}_{\mathbf{2}} , \text{RKey}_{\mathbf{3}} \big)\)</span></p>
<p>Since the Path was constructed by shuffling key-bits from the four parts, <span class="arithmatex">\(\text{Key}_{\mathbf{0}}\)</span>, <span class="arithmatex">\(\text{Key}_{\mathbf{1}}\)</span>, <span class="arithmatex">\(\text{Key}_{\mathbf{2}}\)</span>, <span class="arithmatex">\(\text{Key}_{\mathbf{3}}\)</span>, one would expect the reverse-process (going from the Path-bits to the original key) to work just as easily. </p>
<p>Perhaps taking the level <span class="arithmatex">\(\text{lvl}\)</span> of a leaf and reducing it <em>modulo 4</em>, should be sufficient to tell which part of the Remaining Key, <span class="arithmatex">\(\text{RKey}_{\mathbf{i}}\)</span>, must the Path key-bit be appended to.</p>
<h5 id="example-key-reconstruction">Example. Key Reconstruction</h5>
<p>Suppose the leaf storing the key-value pair <span class="arithmatex">\(\big( \text{Key}_{\mathbf{0123}}, \text{V}_{\mathbf{01..7}}  \big)\)</span> is reached at level 7, the path-bits used are <span class="arithmatex">\(0110101\)</span>, and the remaining key is <span class="arithmatex">\(\text{RKey}_{\mathbf{0123}} = \big( \text{RKey}_{\mathbf{0}} , \text{RKey}_{\mathbf{1}} , \text{RKey}_{\mathbf{2}} , \text{RKey}_{\mathbf{3}} \big)\)</span>.</p>
<p>That is, the path-bits are  <span class="arithmatex">\(\text{path-bit}_6 = 1\)</span>, <span class="arithmatex">\(\text{path-bit}_5 = 0\)</span>, <span class="arithmatex">\(\text{path-bit}_4 = 1\)</span>, <span class="arithmatex">\(\text{path-bit}_3 = 0\)</span>, <span class="arithmatex">\(\text{path-bit}_2 = 1\)</span>, <span class="arithmatex">\(\text{path-bit}_1 = 1\)</span> and <span class="arithmatex">\(\text{path-bit}_0 = 0\)</span>.</p>
<p>So, in order to place <span class="arithmatex">\(\text{path-bit}_6\)</span>, one first computes <span class="arithmatex">\(7 \text{ modulo } 4\)</span> to get <span class="arithmatex">\(3\)</span>. Hence, the <span class="arithmatex">\(\text{key-bit}_6\)</span> must be appended to the third key part, <span class="arithmatex">\(\text{RKey}_{\mathbf{2}}\)</span>.</p>
<p>Next, one climbs the tree to level <span class="arithmatex">\(6\)</span>, where <span class="arithmatex">\(\text{path-bit}_5 = 0\)</span>. One then computes <span class="arithmatex">\(6 \text{ modulo } 4\)</span> and gets <span class="arithmatex">\(2\)</span>. The <span class="arithmatex">\(\text{path-bit}_5\)</span> must then be appended to the second key part, <span class="arithmatex">\(\text{RKey}_{\mathbf{1}}\)</span>.</p>
<p>Again, one climbs the tree to level <span class="arithmatex">\(5\)</span>, where <span class="arithmatex">\(\text{path-bit}_4 = 1\)</span>. Computing  <span class="arithmatex">\(5 \text{ modulo } 4\)</span>  yields <span class="arithmatex">\(1\)</span>. The <span class="arithmatex">\(\text{path-bit}_4\)</span> is thence appended to the first key part, <span class="arithmatex">\(\text{RKey}_{\mathbf{0}}\)</span>.</p>
<p>One then continues in the same fashion; </p>
<p><span class="arithmatex">\(\text{Climbs the tree to level } 4. \text{ Computes }\ 4 \text{ modulo } 4 = 0. \text{ Appends path-bit to the fourth part, } \text{RKey}_{\mathbf{3}}.\)</span>
<span class="arithmatex">\(\text{Climbs the tree to level } 3. \text{ Computes }\ 3 \text{ modulo } 4 = 3. \text{ Appends path-bit to the third part, } \text{RKey}_{\mathbf{2}}.\)</span><span class="arithmatex">\(\text{Climbs the tree to level } 2. \text{ Computes }\ 2 \text{ modulo } 4 = 2. \text{ Appends path-bit to the second part, } \text{RKey}_{\mathbf{1}}.\)</span>
<span class="arithmatex">\(\text{Climbs the tree to level } 1. \text{ Computes }\ 1 \text{ modulo } 4 = 1. \text{ Appends path-bit to the first part, } \text{RKey}_{\mathbf{0}}.\)</span></p>
<p>The next climb is to the root. The navigation path-bits have been exhausted, and the last append has actually completed reconstruction of the key.</p>
<h5 id="leaf-levels-and-integers-modulo-4">Leaf Levels and Integers Modulo 4</h5>
<p>It is clear, from the above example, that there is a one-to-one correspondence between the integers <em>modulo</em> 4 (i.e., Elements of the group <span class="arithmatex">\(\mathbb{Z}_4 = \{ 0, 1, 2, 3 \}\)</span>) and remaining key parts <span class="arithmatex">\(\text{RKey}_{\mathbf{0}} , \text{RKey}_{\mathbf{1}} , \text{RKey}_{\mathbf{2}} , \text{RKey}_{\mathbf{3}}\)</span>. </p>
<p>That is, there is a mapping;</p>
<div class="arithmatex">\[\begin{aligned}
1 \mapsto \text{RKey}_{\mathbf{0}},\ \ 2 \mapsto \text{RKey}_{\mathbf{1}},\ \  3 \mapsto \text{RKey}_{\mathbf{2}} \text{ and }\ 0 \mapsto \text{RKey}_{\mathbf{3}}.
\end{aligned}\]</div>
<p>The quadruple structure of the path bits and the level of leaves therefore have a homomorphic relationship that can be described in terms of the cyclic group of integers modulo 4,  <span class="arithmatex">\(\mathbb{Z}_4 = \{ 0, 1, 2, 3 \}\)</span>.</p>
<p>Since <em>addition modulo n</em> is an expensive computation in the state machine context, it is important to find a more efficient algorithm to achieve the same result.</p>
<h5 id="alternate-cyclic-group-of-order-4">Alternate Cyclic Group Of Order 4</h5>
<p>In order to explore cyclic groups of order 4, take the vector  <span class="arithmatex">\(\mathbf{x} = (1,0,0,0)\)</span> , and rotate the components of <span class="arithmatex">\(\mathbf{x}\)</span> one position to the left.</p>
<p>Note that, rotating   <span class="arithmatex">\(\mathbf{x} = (1,0,0,0)\)</span></p>
<ul>
<li>once, yields <span class="arithmatex">\((0,0,0,1)\)</span>   </li>
<li>twice, one obtains <span class="arithmatex">\((0,0,1,0)\)</span></li>
<li>thrice, one gets <span class="arithmatex">\((0,1,0,0)\)</span>   </li>
<li>four times, and the result is  <span class="arithmatex">\(\mathbf{x} = (1,0,0,0)\)</span> </li>
</ul>
<p>Continuously rotating  <span class="arithmatex">\(\mathbf{x} = (1,0,0,0)\)</span>  will not result in any other vector but the four vectors </p>
<div class="arithmatex">\[
\mathbf{G_4} = \{ (1,0,0,0),\ (0,0,0,1),\ (0,0,1,0),\ (0,1,0,0) \}.
\]</div>
<p>This set of four vectors <span class="arithmatex">\(\mathbf{G_4}\)</span> together with the described <em>rotation</em>, form an group. </p>
<p>In fact, <span class="arithmatex">\(\mathbf{G_4}\)</span> is isomorphic (or homomorphically equivalent) to <span class="arithmatex">\(\mathbb{Z}_4\)</span> under "addition modulo 4". 
That is, there is a natural one-to-one correspondence between the elements of <span class="arithmatex">\(\mathbb{Z}_4\)</span> and those of <span class="arithmatex">\(\mathbf{G_4}\)</span>, as follows;
$$
0 \mapsto (1,0,0,0),\ \ 1 \mapsto (0,1,0,0),\ \ 2 \mapsto (0,0,1,0)\  \text{ and }\ 3 \mapsto (0,0,0,1).
$$</p>
<p>Note that the four numbers <span class="arithmatex">\(0\)</span>, <span class="arithmatex">\(1\)</span>, <span class="arithmatex">\(2\)</span> and <span class="arithmatex">\(3\)</span> can be expressed in their <strong>binary form</strong> with just two bits, and the same one-to-one correspondence holds as;</p>
<div class="arithmatex">\[
\text{00} \mapsto (1,0,0,0),\ \ \text{01} \mapsto (0,1,0,0),\ \ \text{10} \mapsto (0,0,1,0)\  \text{ and }\ \text{11} \mapsto (0,0,0,1).
\]</div>
<h5 id="a-special-cyclic-register-for-leaf-levels">A Special Cyclic Register For Leaf Levels</h5>
<p>Define a register called <code>LEVEL</code> which is vector of four bits, three "0" bits and one "1" bit. And the operation  <code>ROTATE_LEVEL</code>  which is the <em>left rotation</em> of <code>LEVEL</code>'s bits by one position.</p>
<p>If <code>LEVEL</code> is initialised as <span class="arithmatex">\((1,0,0,0)\)</span>, observe that applying <code>ROTATE_LEVEL</code> four times brings <code>LEVEL</code> back to <span class="arithmatex">\((1,0,0,0)\)</span>. That is, 
$$
(1,0,0,0) \to (0,0,0,1)  \to (0,0,1,0) \to (0,1,0,0) \to (1,0,0,0)
$$
Therefore, <code>LEVEL</code> is cyclic under <code>ROTATE_LEVEL</code>, and is in fact algebraically the same as the cyclic group <span class="arithmatex">\(\mathbf{G_4}\)</span> described above.</p>
<p><strong>How is the <code>LEVEL</code> register used in key reconstruction?</strong></p>
<p>First note that, when navigating the tree, the leaf level can be indicated by one of the four possible states of the <code>LEVEL</code> register. And this works for all possible leaf levels because, for any positive integer <span class="arithmatex">\(j\)</span>;</p>
<div class="arithmatex">\[\begin{aligned}
{\text{LEVEL}} = (1,0,0,0)\ \text{indicates that the leaf level is one of the following};\ 0, 4, 8, \dots , 0 + 4j. \ \\
{\text{LEVEL}} = (0,1,0,0)\ \text{indicates that the leaf level is one of the following};\ 1, 5, 9, \dots , 1 + 4j. \ \\
{\text{LEVEL}} = (0,0,1,0)\ \text{indicates that the leaf level is one of the following};\ 2, 6, 10, \dots, 2 + 4j. \\
{\text{LEVEL}} = (0,0,0,1)\ \text{indicates that the leaf level is one of the following};\ 3, 7, 11, \dots, 3 + 4j.
\end{aligned}\]</div>
<p>Second, the two least-significant bits of each of these number, when written in <strong>binary</strong>, are as follows; </p>
<div class="arithmatex">\[\begin{aligned}
\text{Each of these numbers};\ 0, 4, 8, \dots , 0 + 4j;\ \text{ends with } 00.\ \ \\
\text{Each of these numbers};\ 1, 5, 9, \dots , 1 + 4j;\ \text{ends with } 01.\ \ \\
\text{Each of these numbers};\ 2, 6, 10, \dots , 2 + 4j; \text{ends with } 10.\ \\
\text{Each of these numbers};\ 3, 7, 11, \dots , 3 + 4j;\ \text{ends with } 11.
\end{aligned}\]</div>
<p>It suffices therefore to only read the two least-significant bits of the leaf level in order to determine the position of the bit "1" in the <code>LEVEL</code> register.</p>
<p>Third, the position of the bit "1" in the <code>LEVEL</code> register tallies precisely with the part of the remaining key, <span class="arithmatex">\(\text{RKey}_{\mathbf{i}}\)</span>, to which the last used path-bit came from.</p>
<p>So then, when reconstructing the key, one needs only check where the bit "1" is in the <code>LEVEL</code> register, because</p>
<div class="arithmatex">\[\begin{aligned}
{\text{LEVEL}} = (1,0,0,0)\ \ \text{means, the last used path bit must be appended to } \mathbf{RKey_0}.\\
{\text{LEVEL}} = (0,1,0,0)\ \ \text{means, the last used path bit must be appended to } \mathbf{RKey_1}.\\
{ \text{LEVEL}} = (0,0,1,0)\ \ \text{means, the last used path bit must be appended to } \mathbf{RKey_2}.\\
{\text{LEVEL}} = (0,0,0,1)\ \ \text{means, the last used path bit must be appended to } \mathbf{RKey_3}.
\end{aligned}\]</div>
<p>Since things are rather mechanical in state machines, one or two more functions are needed. For instance, one for initialising the <code>LEVEL</code> register, and another for reading the position of the bit "1".</p>
<h3 id="the-textposeidon-hash">The <span class="arithmatex">\(\text{POSEIDON}\)</span> HASH</h3>
<p>Poseidon SM is the most straight forward once one understands the internal mechanism of the original Poseidon hash function. The hash function's permutation process translates readily to the Poseidon SM states. </p>
<p>The <span class="arithmatex">\(\text{POSEIDON}\)</span> State Machine carries out <span class="arithmatex">\(\text{POSEIDON}\)</span> Actions in accordance with instructions from the Main SM Executor and requests from the Storage SM. That is, it computes hashes of messages sent from any of the two SMs, and also checks if the hashes were correctly computed.</p>
<p>The zkProver uses the <em>goldilocks</em> <span class="arithmatex">\(\text{POSEIDON}\)</span> which is defined over the field  <span class="arithmatex">\(\mathbb{F}_p\)</span>, where  <span class="arithmatex">\(p = 2^{64} - 2^{32} + 1\)</span>.</p>
<p>The states of the <span class="arithmatex">\(\text{POSEIDON}\)</span> SM coincide with the twelve (12) internal states of the <span class="arithmatex">\(\text{POSEIDON}^{\pi}\)</span> permutation function. These are;  <code>in0</code>, <code>in1</code>, ... , <code>in7</code>, <code>hashType</code>, <code>cap1</code>, <code>cap2</code> and <code>cap3</code>. </p>
<p><span class="arithmatex">\(\text{POSEIDON}^{\pi}\)</span> runs 30 rounds, 3 times. Adding up to a total of 90 rounds. It outputs four (4) hash values; <code>hash0</code>, <code>hash1</code>, <code>hash2</code> and <code>hash3</code>.</p>
<p><img alt="Figure 16 : POSEIDON HASH0 " src="../fig15-posdn-eg.png" /></p>
<div align="center"><b> Figure 16 : POSEIDON HASH0 </b></div>

<p>In the case of the zkProver storage, two slightly different <span class="arithmatex">\(\text{POSEIDON}\)</span> hashes are used; <span class="arithmatex">\(\text{HASH0}\)</span> is used when a branch node is created, whilst <span class="arithmatex">\(\text{HASH1}\)</span> is used when a leaf node is created. This depends on the <code>hashType</code>, which is a boolean. So <span class="arithmatex">\(\text{POSEIDON}\)</span> acts as <span class="arithmatex">\(\text{HASH1}\)</span> when <code>hashType</code> = 1, and <span class="arithmatex">\(\text{HASH0}\)</span> when <code>hashType</code> = 0. </p>
<p>Since POSEIDON Hashes outputs <span class="arithmatex">\(4 * \lfloor(63.99)\rfloor \text{ bits} = 252\)</span>, and one bit is needed to encode each direction, the tree can therefore have a maximum of 252 levels.</p>
<h2 id="the-storage-state-machines-design-and-mechanism">The Storage State Machine's Design and Mechanism</h2>
<p>The Storage SM is practically dual in that it is both a State Machine and a Storage, a database. So, instead of the Main SM having to query the Storage as a database itself (i.e., the Main SM itself carrying out the CRUD operations), the Storage has instead been automised to execute these queries (by turning it into a state machine).</p>
<p>Since the design of the Storage part has been extensively described in the foregoing sections (in terms of SMTs), the design of the automation now follows. What follows next is the description of,</p>
<ul>
<li>how the State Machine part is designed, and</li>
<li>how it works (i.e., explaining the internal mechanism of the Storage SM). </li>
</ul>
<p>The Storage SM is composed of three parts; Storage Assembly code, Storage Executor code, and the Storage PIL code. </p>
<h3 id="the-storage-assembly">The Storage Assembly</h3>
<p>The Storage Assembly is the interpreter between the Main State Machine and its own Executor. It receives instructions from the Main SM and generates a JSON-file containing the corresponding rules and logic, which are stored in a special ROM for the Storage SM.</p>
<p>The Storage SM has <strong>a primary Storage Assembly code</strong>, <a href="https://github.com/0xPolygonHermez/zkevm-storage-rom/blob/main/zkasm/storage_sm.zkasm">storage_sm.zkasm</a>, that maps each instruction of the Main SM (i.e., each Storage Action) to the secondary Assembly code of the corresponding basic operation. These basic operations are mainly the CREATE, READ, UPDATE and DELETE, as discussed in previous sections.</p>
<p>Considering some special cases, there are all-in-all eight (8) <strong>secondary Storage Assembly codes</strong>, each for a distinct basic operation; READ or Get, UPDATE, CREATE new value at a zero node, CREATE new value at found leaf, DELETE leaf with zero sibling, DELETE last non-zero node, DELETE leaf with non-zero sibling, and SET a zero node to zero. See Table 1, below, for the specific names of the secondary codes.</p>
<div align="center"><b> Table 1: SMT Actions And Secondary zkASM Codes </b></div>

<table>
<thead>
<tr>
<th>Storage Actions</th>
<th>File Names</th>
<th>Code Names</th>
<th>Action Selectors In Primary zkASM Code</th>
</tr>
</thead>
<tbody>
<tr>
<td>READ</td>
<td>Get</td>
<td>Get</td>
<td>isGet()</td>
</tr>
<tr>
<td>UPDATE</td>
<td>Set_Update</td>
<td>SU</td>
<td>isSetUpdate()</td>
</tr>
<tr>
<td>CREATE new value at a found leaf</td>
<td>Set_InsertFound</td>
<td>SIF</td>
<td>isSetInsertFound()</td>
</tr>
<tr>
<td>CREATE new value at a zero node</td>
<td>Set_InsertNotFound</td>
<td>SINF</td>
<td>isSetInsertNotFound()</td>
</tr>
<tr>
<td>DELETE last non-zero node</td>
<td>Set_DeleteLast</td>
<td>SDL</td>
<td>isSetDeleteLast()</td>
</tr>
<tr>
<td>DELETE leaf with non-zero sibling</td>
<td>Set_DeleteFound</td>
<td>SDF</td>
<td>isSetDeleteFound()</td>
</tr>
<tr>
<td>DELETE leaf with zero sibling</td>
<td>Set_DeleteNotFound</td>
<td>SDNF</td>
<td>isSetDeleteNotFound()</td>
</tr>
<tr>
<td>SET a zero node to zero</td>
<td>Set_ZeroToZero</td>
<td>SZTZ</td>
<td>isSetZeroToZero()</td>
</tr>
</tbody>
</table>
<p>Input and ouput states of the Storage SM are literally SMTs, given in the form of; the Merkle roots, the relevant siblings, as well as the key-value pairs.</p>
<p>Note that state machines use registers in the place of variables. All values needed, for carrying out the basic operations, are stored by the primary Assembly code in the following registers; </p>
<p><code>HASH_LEFT</code>, <code>HASH_RIGHT</code>, <code>OLD_ROOT</code>, <code>NEW_ROOT</code>, <code>VALUE_LOW</code>, <code>VALUE_HIGH</code>, <code>SIBLING_VALUE_HASH</code>, <code>RKEY</code>, <code>SIBLING_RKEY</code>, <code>RKEY_BIT</code>, <code>LEVEL</code>.</p>
<p>The <code>SIBLING_VALUE_HASH</code> and <code>SIBLING_RKEY</code> registers are only used by the <code>Set_InsertFound</code> and the <code>Set_DeleteFound</code> secondary Assembly codes. The rest of the registers are used in all the secondary Assembly codes. </p>
<h4 id="smt-action-selectors-in-the-primary-assembly-code">SMT Action Selectors In The Primary Assembly Code</h4>
<p>How does the primary Assembly code map the Main SM instructions to the relevant Storage Actions?  </p>
<p>It uses selectors. Like switches can either be ON or OFF, selectors can either be 1 or 0, where 1 means the action is selected for execution, while 0 means the instruction does not tally with the required action so a "jump if zero" <code>JMPZ</code> is applied.</p>
<p>The primary Assembly code uses selectors by following the sequence in which these Storage Actions are listed in Table 1 above. That is,</p>
<ul>
<li>It first checks if the required action is a <code>Get</code>. If it is so, the <a href="https://github.com/0xPolygonHermez/zkevm-storage-rom/blob/main/zkasm/storage_sm_get.zkasm">storage_sm_get.zkasm</a> code is fetched for execution.</li>
<li>If not, it checks if the required action is <code>Set_Update</code>. If it is so, the <a href="https://github.com/0xPolygonHermez/zkevm-storage-rom/blob/main/zkasm/storage_sm_set_update.zkasm">storage_sm_set_update.zkasm</a> code is fetched for execution.</li>
<li>If not, it continues to check if the required action is <code>Set_InsertFound</code>. If it is so, the <a href="https://github.com/0xPolygonHermez/zkevm-storage-rom/blob/main/zkasm/storage_sm_set_insert_found.zkasm">storage_sm_set_insert_found.zkasm</a> code is fetched for execution.</li>
<li>If not, it continues in the same way until the correct action is selected, in which case the corresponding code is fetched for execution.   </li>
</ul>
<p>That's all the primary Storage Assembly code does, the details of how each if the SMT Actions are stipulated in the individual secondary Assembly codes.</p>
<p>The primary and secondary Storage Assembly files are stored as JSON-files in the Storage ROM, ready to be fetched as "function calls" by the Storage Executor.</p>
<h4 id="the-update-zkasm-code">The UPDATE zkASM Code</h4>
<p>Take as an example the Set_UPDATE zkASM code. The primary Storage Assembly code uses the selector <code>isSetUpdate()</code> for Set_UPDATE. </p>
<p>Note that an UPDATE action involves,</p>
<ol>
<li>Reconstructs the corresponding key, from both the remaining key found at the leaf and key-bits used to navigate to the leaf.</li>
<li>Ascertains that indeed the old value was included in the old root,</li>
<li>Carries out the UPDATE of the old value with the new value, as well as updating all nodes along the path from the leaf to the root. </li>
</ol>
<p>There is only one Set_UPDATE Assembly code, <a href="https://github.com/0xPolygonHermez/zkevm-storage-rom/blob/main/zkasm/storage_sm_set_update.zkasm">storage_sm_set_update.zkasm</a>, for all the above three computations.</p>
<h5 id="key-reconstruction-in-zkasm">Key Reconstruction In zkASM</h5>
<p>Key Reconstruction is achieved in two steps; Positioning of the bit "1" in the <code>LEVEL</code> register, and using the <code>LEVEL</code> register to "climb the RKey". That is, append the path bit last used in navigation to the correct RKey part.</p>
<p>Step 1. <strong>Positioning the bit "1" in the <code>LEVEL</code> register</strong></p>
<p>The Set_UPDATE zkASM code, first initialises the <code>LEVEL</code> register to <code>(1,0,0,0)</code>. </p>
<p>Then uses the <code>GetLevelBit()</code> function to read the two least-significant bits of the leaf level, which happens in two cases, each with its own two subcases;</p>
<ul>
<li>
<p><strong><em>Case 1</em></strong>. If the least-significant bit of leaf level is <code>0</code>, then the <code>GetLevelBit()</code> function is used again to read the second least-significant bit of the leaf level.</p>
</li>
<li>
<p><strong><em>Subcase 1.1</em></strong>: If the second least-significant bit of the leaf level is <code>0</code>, it means the leaf level is a multiple of 4, which is equivalent to 0 because leaf level works in <code>modulo</code> 4. So, the <code>LEVEL</code> register must remain as <code>(1,0,0,0)</code>.</p>
</li>
<li>
<p><strong><em>Subcase 1.2</em></strong>:  If the second least-significant bit of the leaf level is <code>1</code>, it means the leaf level in its binary form ends with a <code>10</code>. Hence, leaf level is a number of the form <code>2 + 4k</code>, for some positive integer <code>k</code>. As a result, the <code>LEVEL</code> register must be rotated to the position, <code>(0,0,1,0)</code>. The code therefore applies <code>ROTATE_LEVEL</code> twice to <code>LEVEL = (1,0,0,0)</code> in order to bring it to <code>(0,0,1,0)</code>.    </p>
</li>
<li>
<p><strong><em>Case 2</em></strong>. If the least-significant bit of leaf level is <code>1</code>, then;</p>
</li>
</ul>
<p>The <code>LEVEL</code> register is rotated three times to the left, using ROTATE_LEVEL, and bringing the <code>LEVEL</code> register to <code>(0,1,0,0)</code>. </p>
<p>Next, the <code>GetLevelBit()</code> function is used again to read the second least-significant bit of the leaf level. </p>
<ul>
<li><strong><em>Subcase 2.1</em></strong>: If the second least-significant bit of the leaf level is <code>0</code>, it means the leaf level in its binary form ends with a <code>01</code>. That is, leaf level is a number of the form <code>1 + 4k</code>, for some positive integer <code>k</code>. And thus, the <code>LEVEL</code> register must remain in its current position, <code>(0,1,0,0)</code>. So it does not need to be rotated.</li>
<li><strong><em>Subcase 2.2</em></strong>: Otherwise, the second least-significant bit of the leaf level is <code>1</code>, which means the leaf level in its binary form ends with a <code>11</code>. Hence, leaf level is a number of the form <code>3 + 4k</code>, for some positive integer <code>k</code>. Consequently, the <code>LEVEL</code> register needs to be rotated from the current position <code>(0,1,0,0)</code> to the position <code>(0,0,0,1)</code>.</li>
</ul>
<p>Step 2. <strong>Using <code>LEVEL</code> to "climb the RKey"</strong></p>
<p>The Remaining Key is fetched using the <code>GetRKey()</code> function and stored in the <code>RKEY</code> register.</p>
<p>When climbing the tree, there are two functions that are used in the code; the CLIMB_RKEY and the ROTATE_LEVEL. </p>
<ul>
<li>First, the <code>LEVEL</code> register is used to pinpoint the correct part of the Remaining Key to which the path-bit last used in the navigation must be appended. (See the previous subsection on "<a href="#a-special-cyclic-register-for-leaf-levels">A Special Cyclic Register For Leaf Levels</a>" for a one-to-one correspondence between the positions of "1" in <code>LEVEL</code> and the Rkey parts.)</li>
<li>Second, the ROTATE_LEVEL is used to rotate the <code>LEVEL</code> register once.  </li>
<li>The CLIMB_RKEY is used; Firstly, to shift the value of the pinpointed RKey part one position to the left. Secondly, to insert the last used path bit to the least-significant position of the shifted-value of the pinpointed RKey part.</li>
</ul>
<p>The above two steps are repeated until all the path bits used in navigation have been appended. In which case, equality between the reconstructed key and the original key is checked. </p>
<h5 id="checking-inclusion-of-old-value-in-old-root">Checking Inclusion Of Old Value In Old Root</h5>
<p>The above key reconstruction, together with checking inclusion of the old value in the old root and updating the old value to the new value, are carried out simultaneously.</p>
<p>Since checking inclusion of the old value in the old root follows the same steps as the update of the old value to the new value, the corresponding lines in the Assembly code are similar. It suffices therefore to explain only one of these two computations.</p>
<p>Next is the discussion of the update of the old value to the new value.</p>
<h5 id="the-update-part-of-set_update">The Update Part Of Set_UPDATE</h5>
<p>All values, <span class="arithmatex">\(\text{V}_{0123}=\big(\text{V}_{0},\text{V}_{1},\text{V}_{2},\text{V}_{3},\text{V}_{4},\text{V}_{5},\text{V}_{6},\text{V}_{7}\big)\)</span> are 256-bit long and expressed as lower half and higher half as, <code>VALUE_LOW</code> <span class="arithmatex">\(=\big(\text{V}_{0},\text{V}_{1},\text{V}_{2},\text{V}_{3}\big)\)</span> and <code>VALUE_HIGH</code> <span class="arithmatex">\(=\big(\text{V}_{4},\text{V}_{5},\text{V}_{6},\text{V}_{7} \big)\)</span>.</p>
<p>Step 1. <strong>Computing the new leaf value</strong></p>
<p>(a) The functions <code>GetValueLow()</code> and <code>GetValueHigh()</code> are used to fetch <code>VALUE_LOW</code> <span class="arithmatex">\(=\big(\text{V}_{0},\text{V}_{1},\text{V}_{2},\text{V}_{3}\big)\)</span> and <code>VALUE_HIGH</code> <span class="arithmatex">\(=\big(\text{V}_{4},\text{V}_{5},\text{V}_{6},\text{V}_{7}\big)\)</span>, respectively.</p>
<p>(b) The <code>VALUE_LOW</code> <span class="arithmatex">\(= \big(\text{V}_{0},\text{V}_{1},\text{V}_{2},\text{V}_{3}\big)\)</span> is stored in a register called <code>HASH_LEFT</code>, whilst <code>VALUE_HIGH</code> <span class="arithmatex">\(=\big(\text{V}_{4},\text{V}_{5},\text{V}_{6},\text{V}_{7}\big)\)</span> is stored in another register called <code>HASH_RIGHT</code>.</p>
<p>(c) The hashed value of <span class="arithmatex">\(\text{V}_{0123}\)</span> is computed using <code>HASH0</code> as, <span class="arithmatex">\(\text{HASH0}\big(\text{HASH\_LEFT}\|\text{HASH\_RIGHT}\big)\)</span>. Note that this is in fact, <span class="arithmatex">\(\text{POSEIDON}\big(0\|0\|0\|0\|\text{VALUE\_LOW}\|\text{VALUE\_HIGH}\big)\)</span>. The hashed value is then stored in <code>HASH_RIGHT</code>.</p>
<p>(This means the <code>HASH_RIGHT</code> and the <code>HASH_LOW</code> are 'make-shift' registers. Whenever a value is stored in it, the old value that was previously stored therein is simply pushed out. They hold values only for the next computation.)</p>
<p>(d) Next the Rkey is copied into the <code>HASH_LEFT</code> register. And the leaf value is computed by using <code>HASH1</code> as, <span class="arithmatex">\(\text{HASH1}\big(\text{HASH\_LEFT}\|\text{HASH\_RIGHT}\big)\)</span>. i.e., The value of the leaf is, <span class="arithmatex">\(\text{HASH1}\big( \text{RKey}\|\text{HashedValue}\big)\)</span>. The leaf value is then copied into another register called <code>NEW_ROOT</code>. </p>
<p>Step 2. <strong>Climbing the SMT</strong></p>
<p>Check if the path bit that led to the leaf is 0 or 1, by using the <code>GetNextKeyBit()</code> function.</p>
<p><strong>Case 1</strong>: If the path bit (called 'key bit' in the code) is 0, then the corresponding sibling is on the right. Therefore, using 'jump if zero' <code>JMPZ</code>,  the code jumps to the <code>SU_SiblingIsRight</code> routine. </p>
<p>(a) The leaf value in <code>NEW_ROOT</code> is pushed into the <code>HASH_LEFT</code> register. </p>
<p>(b) The hash value of the sibling node is fetched, using the <code>GetSiblingHash()</code> function. And it is pushed into the <code>HASH_RIGHT</code> register.</p>
<p>(c) The hash value of the parent node is computed using <code>HASH0</code> as follows, <span class="arithmatex">\(\text{HASH0}\big(\text{HASH\_LEFT}\|\text{HASH\_RIGHT}\big)\)</span>. </p>
<p>i.e., The parent node is <span class="arithmatex">\(\text{POSEIDON}\big(0\|0\|0\|0\|\text{LeafValue}\|\text{SiblingHash}\big)\)</span>.</p>
<p><strong>Case 2</strong>: If the path bit is 1, then the corresponding sibling is on the left. The routine <code>SU_SiblingIsRight</code> is then executed. </p>
<p>(a) The leaf value in <code>NEW_ROOT</code> is pushed into the <code>HASH_RIGHT</code> register. </p>
<p>(b) The hash value of the sibling node is fetched, using the <code>GetSiblingHash()</code> function. And it is pushed into the <code>HASH_LEFT</code> register.</p>
<p>(c) The hash value of the parent node is computed using <code>HASH0</code> as follows, <span class="arithmatex">\(\text{HASH0}\big(\text{HASH\_LEFT}\|\text{HASH\_RIGHT}\big)\)</span>. </p>
<p>i.e., The parent node is <span class="arithmatex">\(\text{POSEIDON}\big(0\|0\|0\|0\|\text{SiblingHash}\|\text{LeafValue}\big)\)</span>. </p>
<p>Step 3. <strong>Check if tree top has been reached</strong></p>
<p>The code uses the function <code>GetTopTree()</code> to check is the top of the tree has been reached.</p>
<p><strong>Case 1</strong>. If  <code>GetTopTree()</code>  returns 1, then Step 2 is repeated. But this time using the hash value of the corresponding sibling at the next level (i.e., at <code>leaf level - 1</code>). </p>
<p><strong>Case 2</strong>.  If  <code>GetTopTree()</code>  returns 0, then the code jumps to the <code>SU_Latch</code> routine. </p>
<p>The <code>SU_Latch</code> is an overall routine for the entire Set_UPDATE Assembly code. It is here where, </p>
<p>(a) Equality between the reconstructed key and the original key is checked.</p>
<p>(b) Equality between the computed old root value and the original old root is checked.</p>
<p>Once consistency is established both between the keys and the old roots, then all new values; the new root, the new hash value, and the new leaf value; are set using <code>LATCH_SET</code>. </p>
<h4 id="the-rest-of-the-secondary-assembly-codes">The Rest Of The Secondary Assembly Codes</h4>
<p>The Assembly codes for the other seven SMT Actions to a certain extent, follow a similar pattern except for a few cases where especially adjusted routines are used.</p>
<p>Actions such as; </p>
<ol>
<li>The <code>Set_InsertFound</code> (or <code>SIF</code>) may involve a change in the topology of the SMT by extending a branch once or several times. </li>
</ol>
<p>In cases where a branch has been extended, the SIF Assembly code, when computing the new root, uses another routine called <code>SIF_ClimbBranch</code> just for updating values along the newly extended branch. This is done in addition to the <code>SIF_ClimbTree</code>, which is the exact same routine as the aforementioned <code>SU_ClimbTree</code> of the <code>Set_UPDATE</code> case.</p>
<p>It is for the same reason, SIF Assembly utilises special registers; the <code>SIBLING_VALUE_HASH</code> and <code>SIBLING_RKEY</code>. </p>
<ol>
<li>The opposite SMT Action, the <code>Set_DeleteFound</code> or <code>SDF</code>, may entail a previously extended branch being reserved. </li>
</ol>
<p>As in the SIF case, if a branch had been extended but now the extension needs to be reversed due to a deleted leaf value, a special routine called <code>SDF_ClimbBranch</code> is used when updating values of nodes along the newly shortened branch. This <code>SDF_ClimbBranch</code> routine is the exact same routine as the<code>SIF_ClimbBranch</code>. Similarly, the SDF Assembly code uses the <code>SDF_ClimbTree</code> as in the Set_UPDATE Assembly.</p>
<p>Note also that there is only one <code>Get</code> Assembly code, for the READ SMT Action, and the rest of the secondary Assembly codes are <code>Set_</code> Assembly codes differing according to their respective SMT Actions. So <code>Get</code> uses <code>LATCH_GET</code> at the end of a run, while the <code>Set_</code> codes use <code>LATCH_SET</code>.</p>
<h3 id="the-storage-executor">The Storage Executor</h3>
<p>The Storage Executor like a slave-worker to the master, the Storage Assembly code, carries out all SMT Actions in accordance with rules and logic that the Assembly code has set out.</p>
<p>As per instruction of the Main SM, the Storage Executor makes function calls to the Storage ROM for a specific secondary Assembly code stored as a JSON-file, by using the same aforementioned <em>selectors</em> of secondary Assembly codes. </p>
<p>For example, if the Main SM requires a new leaf to be created at a found non-zero leaf, the Storage Executor uses <code>isSetInsertFound</code> as a function call for the <code>Set_InsertFound</code> (or <code>SIF</code>) SMT Action. The Storage Executor then proceeds to build commited polynomials and executes the <code>SIF</code> SMT Action.</p>
<p>As previously observed, in our very first UPDATE example in this document, all values are expressed as quadruplets of unsigned integers. For example, the Remaining Key looks like this,
$$
\text{RKey} = \big( \text{RKey}_0, \text{RKey}_1, \text{RKey}_2, \text{RKey}_3 \big)
$$
The Executor therefore uses an internal 4-element register called <code>op = [_,_,_,_]</code>, for handling values from the Storage ROM, which are needed in the internal step-by-step evaluations of the SMT Action being executed. It is thus reset to 0 after every evaluation.</p>
<p>All the function calls seen in the Assembly code; </p>
<p><code>GetSibling()</code>, <code>GetValueLow()</code>, <code>GetValueHigh()</code>, <code>GetRKey()</code>, <code>GetSiblingRKey()</code>, <code>GetSiblingHash()</code>, <code>GetSiblingValueLow()</code>, <code>GetSiblingValueHigh()</code>, <code>GetOldValueLow()</code>, <code>GetOldValueHigh()</code>, <code>GetLevelBit()</code>, <code>GetTopTree()</code>, <code>GetTopBranch()</code> and <code>GetNextKeyBit()</code>; </p>
<p>are actually performed by the Storage Executor. The values being fetched are carried with the <code>op</code> register. For instance, if the function call is <code>GetRKey()</code> then the Storage Executor gets the RKey from the rom.line file, carries it with <code>op</code> as; </p>
<p><code>op[0] = ctx.rkey[0];</code> </p>
<p><code>op[1] = ctx.rkey[1];</code></p>
<p><code>op[2] = ctx.rkey[2];</code></p>
<p><code>op[3] = ctx.rkey[3];</code></p>
<p>where <code>ctx</code> signifies an SMT Action. </p>
<p>Also, since all SMT Actions require some hashing, the Storage SM delegates all hashing Actions to the <span class="arithmatex">\(\text{POSEIDON}\)</span> SM. However, from within the Storage SM, it is best to treat the <span class="arithmatex">\(\text{POSEIDON}\)</span> SM as a blackbox. The Storage Executor simply specifies the sets of twelve values to be digested. And the <span class="arithmatex">\(\text{POSEIDON}\)</span> SM then returns the required digests of the values.   </p>
<h3 id="the-storage-pil">The Storage PIL</h3>
<p>All computations executed in the Storage SM must be verifiable. A special Polynomial Identity Language (PIL) code is therefore used to set up all the polynomial constraints the verifier needs to validate correctness of execution.</p>
<p>The preparation for these polynomial constraints actually starts in the Storage Executor. In order to accomplish this, the Storage Executor uses; selectors, setters and instructions; which are in fact Boolean polynomials. See the list of these Boolean committed polynomials in Table 2, below.</p>
<div align="center"><b> Table 2: Boolean Polynomials For Execution Tracing </b></div>

<table>
<thead>
<tr>
<th align="left">Selectors</th>
<th align="left">Setters</th>
<th align="left">Instructions</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">selFree[i]</td>
<td align="left">setHashLeft[i]</td>
<td align="left">iHash</td>
</tr>
<tr>
<td align="left">selSiblingValueHash[i]</td>
<td align="left">setHashRight[i]</td>
<td align="left">iHashType</td>
</tr>
<tr>
<td align="left">selOldRoot[i]</td>
<td align="left">setOldRoot[i]</td>
<td align="left">iLatchSet</td>
</tr>
<tr>
<td align="left">selNewRoot[i]</td>
<td align="left">setNewRoot[i]</td>
<td align="left">iLatchGet</td>
</tr>
<tr>
<td align="left">selValueLow[i]</td>
<td align="left">setValueLow[i]</td>
<td align="left">iClimbRkey</td>
</tr>
<tr>
<td align="left">selValueHigh[i]</td>
<td align="left">setValueHigh[i]</td>
<td align="left">iClimbSiblingRkey</td>
</tr>
<tr>
<td align="left">selRkeyBit[i]</td>
<td align="left">setSiblingValueLow[i]</td>
<td align="left">iClimbSiblngRkeyN</td>
</tr>
<tr>
<td align="left">selSiblingRkey[i]</td>
<td align="left">setSiblingValueHigh[i]</td>
<td align="left">iRotateLevel</td>
</tr>
<tr>
<td align="left">selRkey[i]</td>
<td align="left">setRkey[i]</td>
<td align="left">iJmpz</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">setSiblingRkey[i]</td>
<td align="left">iConst0</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">setRkeyBit[i]</td>
<td align="left">iConst1</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">setLevel[i]</td>
<td align="left">iConst2</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"></td>
<td align="left">iConst3</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"></td>
<td align="left">iAddress</td>
</tr>
</tbody>
</table>
<p>Everytime each of these Boolean polynomials are utilised or performed, a record of a "1" is kept in its register. This is called an <strong>execution trace</strong>. </p>
<p>Therefore, instead of performing some expensive computations in order to verify correctness of execution (at times repeating the same computations being verified), the trace of execution is tested. The verifier takes the execution trace, and tests if it satisfies the polynomial constraints (or identities) in the PIL code. This technique helps the zkProver to achieve succintness as a zero-knowledge proof/verification system.</p>

              
            </article>
            
          </div>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
    
    <nav class="md-footer__inner md-grid" aria-label="Footer" >
      
        
        <a href="../../Arithmetic/Arithmetic-State-Machine-typ/" class="md-footer__link md-footer__link--prev" aria-label="Previous: Arithmetic" rel="prev">
          <div class="md-footer__button md-icon">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12Z"/></svg>
          </div>
          <div class="md-footer__title">
            <div class="md-ellipsis">
              <span class="md-footer__direction">
                Previous
              </span>
              Arithmetic
            </div>
          </div>
        </a>
      
      
        
        <a href="../../Hashing/Hashing-State-Machine-typ/" class="md-footer__link md-footer__link--next" aria-label="Next: Hashing" rel="next">
          <div class="md-footer__title">
            <div class="md-ellipsis">
              <span class="md-footer__direction">
                Next
              </span>
              Hashing
            </div>
          </div>
          <div class="md-footer__button md-icon">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M4 11v2h12l-5.5 5.5 1.42 1.42L19.84 12l-7.92-7.92L10.5 5.5 16 11H4Z"/></svg>
          </div>
        </a>
      
    </nav>
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
        <div class="md-social">
  
    
    
      
      
    
    <a href="https://t.me/polygonhermez" target="_blank" rel="noopener" title="t.me" class="md-social__link">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><!--! Font Awesome Free 6.1.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc.--><path d="M248 8C111.033 8 0 119.033 0 256s111.033 248 248 248 248-111.033 248-248S384.967 8 248 8Zm114.952 168.66c-3.732 39.215-19.881 134.378-28.1 178.3-3.476 18.584-10.322 24.816-16.948 25.425-14.4 1.326-25.338-9.517-39.287-18.661-21.827-14.308-34.158-23.215-55.346-37.177-24.485-16.135-8.612-25 5.342-39.5 3.652-3.793 67.107-61.51 68.335-66.746.153-.655.3-3.1-1.154-4.384s-3.59-.849-5.135-.5q-3.283.746-104.608 69.142-14.845 10.194-26.894 9.934c-8.855-.191-25.888-5.006-38.551-9.123-15.531-5.048-27.875-7.717-26.8-16.291q.84-6.7 18.45-13.7 108.446-47.248 144.628-62.3c68.872-28.647 83.183-33.623 92.511-33.789 2.052-.034 6.639.474 9.61 2.885a10.452 10.452 0 0 1 3.53 6.716 43.765 43.765 0 0 1 .417 9.769Z"/></svg>
    </a>
  
    
    
      
      
    
    <a href="https://github.com/hermeznetwork/hermez-docs" target="_blank" rel="noopener" title="github.com" class="md-social__link">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><!--! Font Awesome Free 6.1.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc.--><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg>
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    <script id="__config" type="application/json">{"base": "../../../..", "features": ["navigation.tabs", "navigation.tabs.sticky", "navigation.tracking"], "search": "../../../../assets/javascripts/workers/search.b97dbffb.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.config.lang": "en", "search.config.pipeline": "trimmer, stopWordFilter", "search.config.separator": "[\\s\\-]+", "search.placeholder": "Search", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version.title": "Select version"}}</script>
    
    
      <script src="../../../../assets/javascripts/bundle.6c7ad80a.min.js"></script>
      
        <script src="../../../../javascripts/mathjax.js"></script>
      
        <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
      
        <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
      
    
  </body>
</html>